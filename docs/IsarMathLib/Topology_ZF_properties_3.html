<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Topology_ZF_properties_3 (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Topology_ZF_properties_3</h1>

<span class="command">theory</span> <span class="name">Topology_ZF_properties_3</span><br/>
<span class="keyword">imports</span> <a href="Topology_ZF_9.html"><span class="name">Topology_ZF_9</span></a> <a href="Topology_ZF_properties_2.html"><span class="name">Topology_ZF_properties_2</span></a> <a href="FinOrd_ZF.html"><span class="name">FinOrd_ZF</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
    This file is a part of IsarMathLib - 
    a library of formalized mathematics written for Isabelle/Isar.

    Copyright (C) 2013 Daniel de la Concepcion

    This program is free software; Redistribution and use in source and binary forms, 
    with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation and/or 
   other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products 
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Properties in Topology 3&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Topology_ZF_properties_3</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Topology_ZF_7</span><span> </span><span>Finite_ZF_1</span><span> </span><span>Topology_ZF_1b</span><span> </span><span>Topology_ZF_9</span><span>
</span><span>  </span><span>Topology_ZF_properties_2</span><span> </span><span>FinOrd_ZF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This theory file deals with more topological properties and the
relation with the previous ones in other theory files.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;More anti-properties&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section we study more anti-properties.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First examples&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A first example of an anti-compact space is the discrete space.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pow_compact_imp_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B{is compact in}Pow(A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(B)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(Pow(A)). B&#8838;&#8899;M &#10230;(&#8707;N&#8712;FinPow(M). B&#8838;&#8899;N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{{x}. x&#8712;B}&#8712;Pow(Pow(A))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;{{x}. x&#8712;B}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;FinPow({{x}. x&#8712;B}). B&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8712;FinPow({{x}. x&#8712;B})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(N)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8838;{{x}. x&#8712;B}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(N)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b&#8712;N. Finite(b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(&#8899;N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Union</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>pow_anti_compact</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A){is anti-compact}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;Pow(A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(A){restricted to}B)){is compact in}(Pow(A){restricted to}B)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(B)=Pow(A){restricted to}B&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;Pow(B)){is compact in}Pow(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B{is compact in}Pow(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_compact_imp_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In a previous file, @{file &quot;Topology_ZF_5.thy&quot;}, we proved that
the spectrum of the lindelöf property depends on the axiom of countable choice
on subsets of the power set of the natural number.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this context, the examples depend on wether this choice principle holds or not.
This is the reason that the examples of anti-lindeloef topologies are left for the next
section.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Structural results&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We first differenciate the spectrum of the lindeloef property depending
on some axiom of choice.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lindeloef_spec1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{the axiom of} nat {choice holds for subsets}(Pow(nat))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A {is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))) &#10231; (A&#8818;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compactK_spectrum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lindeloef_spec2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;({the axiom of} nat {choice holds for subsets}(Pow(nat)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A {is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))) &#10231; Finite(A)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of} (&#955;T. ((&#8899;T){is compact in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8818;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span>le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact in}T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact of cardinal}nat{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact of cardinal}csucc(nat){in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>compact_greater_card</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is lindeloef in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;T. T{is a topology} &#10230; ((&#8899;T){is compact in}T) &#10230; ((&#8899;T){is lindeloef in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A {is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_imp_Q_spec_inv</span><span class="delimiter">[</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;T. ((&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;T. ((&#8899;T){is lindeloef in}T)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A {is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;T. T{is a topology}&#8743;&#8899;T&#8776;A &#10230; ((&#8899;T){is compact of cardinal} csucc(nat){in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is compact of cardinal} csucc(nat) {in} Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(Pow(A)). A&#8838;&#8899;M &#10230; (&#8707;N&#8712;Pow(M). A&#8838;&#8899;N &#8743; N&#8826;csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompactOfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{{x}. x&#8712;A}&#8712;Pow(Pow(A))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=&#8899;{{x}. x&#8712;A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;Pow({{x}. x&#8712;A}). A&#8838;&#8899;N &#8743; N&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8712;Pow({{x}. x&#8712;A})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8838;{{x}. x&#8712;A}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{{x}. x&#8712;A}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;A&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;t={x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A&#8838;&#8899;N&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;N&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;B&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#8838;{{x}. x&#8712;A}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B={x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t={x}&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;B&#8712;N&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#8838;{{x}. x&#8712;A}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N={{x}. x&#8712;A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;x,{x}&#10217;. x&#8712;A}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N={{x}. x&#8712;A}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?B:A&#8594; N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N={{x}. x&#8712;A}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?B:inj(A,N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#8826;csucc(nat)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span> </span><span>Card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;nat&#8744;A&#8776;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_iff_leqpoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8776;nat&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8776;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat {is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equipollent_spect</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(nat){is a topology}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;Pow(nat)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;Pow(nat)&#8776;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat {is compact of cardinal} csucc(nat){in}Pow(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_disc_comp_csuccQ_eq_Q_choice_csuccQ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_nat_is_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If the axiom of countable choice on subsets of the pow of the natural numbers
doesn&#39;t hold, then anti-lindeloef spaces are anti-compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>no_choice_imp_anti_lindeloef_is_anti_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;({the axiom of} nat {choice holds for subsets}(Pow(nat)) )&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is anti-lindeloef}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is anti-compact}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8818;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span>le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact in}T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact of cardinal}nat{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is compact of cardinal}csucc(nat){in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>compact_greater_card</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is lindeloef in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;T. T{is a topology} &#10230; ((&#8899;T){is compact in}T) &#10230; ((&#8899;T){is lindeloef in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>eq_spect_rev_imp_anti</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>lindeloef_spec2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>compact_spectrum</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiLin_def</span><span> </span><span>IsAntiComp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If the axiom of countable choice holds for subsets of the power set of the
natural numbers, then there exists a topological space that is anti-lindeloef
but no anti-compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>no_choice_imp_anti_lindeloef_is_anti_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({the axiom of} nat {choice holds for subsets}(Pow(nat)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({one-point compactification of}Pow(nat)){is anti-lindeloef}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;({one-point compactification of}Pow(nat))={nat}&#8746;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.op_compact_total</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">]</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&#8746;nat&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&#8746;nat&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;({one-point compactification of}Pow(nat))&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;Pow(&#8899;({one-point compactification of}Pow(nat)))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(({one-point compactification of}Pow(nat)){restricted to}A)){is lindeloef in}(({one-point compactification of}Pow(nat)){restricted to}A)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;({one-point compactification of}Pow(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span>lepoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}(&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span>lindeloef_spec1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiLin_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>op_comp_pow_nat_no_anti_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(({one-point compactification of}Pow(nat)){is anti-compact})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;({one-point compactification of}Pow(nat)){restricted to}({nat} &#8746; nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>antiComp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;({one-point compactification of}Pow(nat)){is anti-compact}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({nat} &#8746; nat){is compact in}({one-point compactification of}Pow(nat))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.compact_op</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Pow_is_top</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({nat} &#8746; nat){is compact in}?T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?T=(&#8899;({one-point compactification of}Pow(nat)))&#8745;({nat} &#8746; nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?T={nat} &#8746; nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.op_compact_total</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;?T){is compact in}?T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>antiComp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({nat} &#8746; nat){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span>
</span><span>    </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.op_compact_total</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({nat} &#8746; nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_not_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In coclusion, we reached another equivalence of this choice principle.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The axiom of countable choice holds for subsets of the power set of the
natural numbers if and only if there exists a topological space which is anti-lindeloef
but not anti-compact; this space can be chosen as the one-point compactification
of the discrete topology on $\mathbb{N}$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>acc_pow_nat_equiv1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({the axiom of} nat {choice holds for subsets}(Pow(nat))) &#10231; (({one-point compactification of}Pow(nat)){is anti-lindeloef})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_pow_nat_no_anti_comp</span><span> </span><span>no_choice_imp_anti_lindeloef_is_anti_comp</span><span>
</span><span>  </span><span>topology0.no_choice_imp_anti_lindeloef_is_anti_comp</span><span> </span><span>topology0.op_comp_is_top</span><span>
</span><span>  </span><span>Pow_is_top</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>acc_pow_nat_equiv2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({the axiom of} nat {choice holds for subsets}(Pow(nat))) &#10231; (&#8707;T. T{is a topology}
  &#8743; (T{is anti-lindeloef}) &#8743; &#172;(T{is anti-compact}))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_pow_nat_no_anti_comp</span><span> </span><span>no_choice_imp_anti_lindeloef_is_anti_comp</span><span>
</span><span>  </span><span>topology0.no_choice_imp_anti_lindeloef_is_anti_comp</span><span> </span><span>topology0.op_comp_is_top</span><span>
</span><span>  </span><span>Pow_is_top</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In the file @{file &quot;Topology_ZF_properties.thy&quot;}, it is proven that $\mathbb{N}$ is
lindeloef if and only if the axiom of countable choice holds for subsets of $Pow(\mathbb{N})$.
Now we check that, in ZF, this space is always anti-lindeloef.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_anti_lindeloef</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(nat){is anti-lindeloef}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;Pow(&#8899;Pow(nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(nat){restricted to}A)){is lindeloef in}(Pow(nat){restricted to}A)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(nat){restricted to}A=Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is lindeloef in}Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>T</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8776;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;bij(A,&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;surj(A,&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IsContinuous(Pow(A),T,f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsContinuous_def</span><span>
</span><span>        </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;two_top_spaces0(Pow(A),T,f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>two_top_spaces0_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>T</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T){is lindeloef in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>two_top_spaces0.cont_image_com</span><span>
</span><span>        </span><span>lin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of} (&#955;T. ((&#8899;T){is lindeloef in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiLin_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This result is interesting because depending on the different axioms we add
to ZF, it means two different things: 
\begin{itemize}
\item Every subspace of $\mathbb{N}$ is Lindeloef.
\item Only the compact subspaces of $\mathbb{N}$ are Lindeloef.
\end{itemize}
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Now, we could wonder if the class of compact spaces and the class of lindeloef spaces being equal
is consistent in ZF. Let&#39;s find a topological space which is lindeloef and no compact
without assuming any axiom of choice or any negation of one. This will prove
that the class of lindeloef spaces and the class of compact spaces cannot be equal
in any model of ZF.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lord_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LOrdTopology nat Le)={LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8800;0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8712;U&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat}&#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8713;U&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UU</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;{LeftRayX(nat,Le,n). n&#8712;nat}&#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i. i&#8712;nat&#8743; &#8899;U&#8838; LeftRayX(nat,Le,i)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#956; i. i&#8712;nat &#8743; &#8899;U&#8838; LeftRayX(nat,Le,i)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?M&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8838; LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>nat_into_Ord</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;i. i&#8712;nat &#8743; &#8899;U&#8838; LeftRayX(nat,Le,i)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;LeftRayX(nat,Le,?M)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;V&#8712;U. y&#8713;V&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat,Le,n)&#8712;U}. y&#8713;LeftRayX(nat,Le,m)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat,Le,n)&#8712;U}. &#10216;y,m&#10217;&#8713;Le&#8744;y=m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>RR</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat,Le,n)&#8712;U}. &#10216;m,y&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLinOrder_def</span><span> </span><span>IsTotal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>rr</span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr&#8712;&#8899;U&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr&#8712;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UU</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V=LeftRayX(nat,Le,m)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>RR</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;m,y&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>m</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;rr,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr&#8712;nat-{m}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;rr,y&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLinOrder_def</span><span>
</span><span>                </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr=y&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLinOrder_def</span><span> </span><span>antisym_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr&#8712;LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8838;LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span>M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?M,y&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Least_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLinOrder_def</span><span> </span><span>antisym_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LeftRayX(nat,Le,?M)&#8838;&#8899;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U=LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;i. i &#8712; nat &#8743; &#8899;U &#8838; LeftRayX(nat, Le, i))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i. i&#8712;nat &#10230; &#172;(&#8899;U &#8838; LeftRayX(nat, Le, i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&#8712;nat&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8899;U &#8838; LeftRayX(nat, Le, i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8713;&#8899;U&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;V&#8712;U. i&#8713;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat, Le, n)&#8712;U}. i&#8713;LeftRayX(nat, Le, m)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat, Le, n)&#8712;U}. &#10216;i,m&#10217;&#8713;Le&#8744;i=m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat, Le, n)&#8712;U}. &#172;(i&#8804;m)&#8744;i=m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Le_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat, Le, n)&#8712;U}. m&lt;i&#8744;m=i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_le_iff_lt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>              </span><span>nat_into_Ord</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;{n&#8712;nat. LeftRayX(nat, Le, n)&#8712;U}. m&#8804;i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_iff</span><span> </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;U&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;LeftRayX(nat, Le, n)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LeftRayX(nat, Le, n)&#8712;U&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ni</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#8804;n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8800;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8804;i&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8800;i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sn</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ni</span><span class="delimiter">]</span><span> </span><span>le_anti_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sn</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>ni</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;LeftRayX(nat, Le, i)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>le_in_nat</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8712;&#8899;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8838;&#8899;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U=0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U. U&#8838;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#10230; &#8899;U&#8712;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}={&#8899;U. U&#8712;Pow({LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat})}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LOrdtopology_ROrdtopology_are_topologies</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAbaseFor_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countable_lord_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}&#8826;csucc(nat)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{e}&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{e}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">]</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{e}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat} &#8746;{0}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{nat}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{0}&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?FF</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,LeftRayX(nat,Le,n)&#10217;. n&#8712;nat}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?FF:nat&#8594;{LeftRayX(nat,Le,n). n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>domain_def</span><span> </span><span>function_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?FF&#8712;surj(nat,{LeftRayX(nat,Le,n). n&#8712;nat})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>
</span><span>    </span><span>OF</span><span> </span><span>_</span><span> </span><span>ff</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat,Le,n). n&#8712;nat}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_fun_inv_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>su</span><span> </span><span>lepoll_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>Ord_nat</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat,Le,n). n&#8712;nat}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat, Le, n) . n &#8712; nat} &#8746; ({nat} &#8746; {0}) &#8826; csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{LeftRayX(nat, Le, n) . n &#8712; nat} &#8746; ({nat} &#8746; {0})={LeftRayX(nat, Le, n) . n &#8712; nat} &#8746; {nat} &#8746; {0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>lindelof_lord_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat{is lindeloef in}(LOrdTopology nat Le)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLindeloef_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>countable_lord_nat</span><span> </span><span>lord_nat</span><span> </span><span>card_top_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span>union_lordtopology_rordtopology</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>not_comp_lord_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(nat{is compact in}(LOrdTopology nat Le))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat{is compact in}(LOrdTopology nat Le)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lord_nat</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat{is compact in}({LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow({LeftRayX(nat,Le,n). n&#8712;nat} &#8746;{nat} &#8746;{0}). nat&#8838;&#8899;M &#10230; (&#8707;N&#8712;FinPow(M). nat&#8838;&#8899;N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&lt;succ(n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,succ(n)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8800;succ(n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>nat_succ_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;LeftRayX(nat,Le,succ(n))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;&#8899;({LeftRayX(nat,Le,n). n&#8712;nat})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>nat_succ_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;FinPow({LeftRayX(nat,Le,n). n&#8712;nat}). nat&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8712;FinPow({LeftRayX(nat,Le,n). n&#8712;nat})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N&#8838;{LeftRayX(nat,Le,n). n&#8712;nat}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(N)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?F</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,LeftRayX(nat,Le,n)&#10217;. n&#8712;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?F:{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N} &#8594; N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F&#8712;surj({m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}, N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>
</span><span>    </span><span>OF</span><span> </span><span>_</span><span> </span><span>ff</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xyF</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F`x=?F`y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F`x=LeftRayX(nat,Le,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F`y=LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>
</span><span>      </span><span>OF</span><span> </span><span>_</span><span> </span><span>ff</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xyF</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lxy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;LeftRayX(nat,Le,x)=LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8800;x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xyF</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;LeftRayX(nat,Le,x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_in_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lxy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8800;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;r. r&lt;x &#10230; r&lt;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(y&lt;x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8800;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xyF</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;LeftRayX(nat,Le,y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_in_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;LeftRayX(nat,Le,x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lxy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8800;x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(x&lt;y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_lt_iff_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nat_into_Ord</span><span> </span><span>nat_into_Ord</span><span class="delimiter">]</span><span> </span><span>xyF</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span>le_anti_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F&#8712;inj({m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}, N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?F&#8712;bij({m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}, N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}&#8776; N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Finite({m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_Finite</span><span> </span><span>eqpoll_imp_lepoll</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Maximum(Le,{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?M&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LeftRayX(nat,Le,?M)&#8712;N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#120117;&#8712;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}. &#10216;&#120117;,?M&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span>linord_max_props</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>nE</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span>&#120117;</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120117;&#8712;V&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V=LeftRayX(nat,Le,m)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LeftRayX(nat,Le,m)&#8712;N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;&#120117;,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120117;&#8800;m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>m</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;{m&#8712;nat. LeftRayX(nat,Le,m)&#8712;N}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mM</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;m,?M&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;&#120117;,?M&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Le_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120117;=?M&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xx</span><span> </span><span>mM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_anti_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120117;&#8712;LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;N&#8838;LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;N=LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8838;LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(?M)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_succI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(?M)&#8712;LeftRayX(nat,Le,?M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;succ(?M),?M&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LeftRayX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;More Separation properties&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section we study more separation properties.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definitions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We start with a property that has already appeared in
@{file &quot;Topology_ZF_1b.thy&quot;}. A KC-space is a space where
compact sets are closed.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsKC</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is KC}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC} &#8801; &#8704;A&#8712;Pow(&#8899;T). A{is compact in}T &#10230; A{is closed in}T&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Another type of space is an US-space; those where sequences
have at most one limit.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsUS</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_{is US}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is US} &#8801; &#8704;N x y. (N:nat&#8594;&#8899;T) &#8743; NetConvTop(&#10216;N,Le&#10217;,x,T) &#8743; NetConvTop(&#10216;N,Le&#10217;,y,T) &#10230; y=x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First results&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The proof in @{file &quot;Topology_ZF_1b.thy&quot;} shows that a Hausdorff space
is KC.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>T2_imp_KC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is T<span class="hidden">&#8681;</span><sub>2</sub>}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is compact in}T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_t2_compact_is_cl</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;From the spectrum of compactness, it follows that any KC-space
is $T_1$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>KC_imp_T1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({x})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(T{restricted to}{x}){is a topology}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_1_L4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}{x})={x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>com</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{x}{is compact in}(T{restricted to}{x})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}{is compact in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_subspace_imp_compact</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T1_iff_singleton_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Even more, if a space is KC, then it is US. We already know that
for $T_2$ spaces, any net or filter has at most one limit; and that
this property is equivalent with $T_2$. The US property is much weaker
because we don&#39;t know what happends with other nets that are not directed by
the order on the natural numbers.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>KC_imp_US</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is US}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span>x</span><span> </span><span>y</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8800;y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Le directs nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(N)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Net</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). x&#8712;int(U) &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n&#8712;nat. &#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{y}{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span>T1_iff_singleton_closed</span><span> </span><span>KC_imp_T1</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>o2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-{y}&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int(&#8899;T-{y})=&#8899;T-{y}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>o3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(&#8899;T-{y})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>o2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-{y}&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>o1</span><span> </span><span>o3</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;&#8899;T-{y}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dir</span><span> </span><span>r</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,z&#10217;&#8712;Le&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,z&#10217;&#8712;Le&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;z&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsDirectedSet_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z&#8712;&#8899;T-{y}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#8707;m&#8712;nat. N`m&#8800;y &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?NN</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,N`(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;. n&#8712;nat}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x, z&#10217; &#8712; ?NN&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y&#39;</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x,y&#39;&#10217;&#8712;?NN&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x z. &#10216;x, z&#10217; &#8712; ?NN &#10230; (&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;y &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;y &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,N`(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;&#8712;nat&#215;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN&#8712;Pow(nat&#215;&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span>domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;y &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;y &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;y &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8800;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8800;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?NN)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>net2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NFun</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;y &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conv2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>dom2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8746;?NN``nat&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Acov</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;T&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U=int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>conv2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom2</span><span> </span><span>UT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NresFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}):{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_fun</span><span>
</span><span>        </span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})&#8712;surj({n&#8712;nat. &#10216;n,r&#10217;&#8712;Le},range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}))&#8818;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_fun_inv_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,0&#10217;&#8712;Le}={0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,0&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,succ(j)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8804;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;j &#8746;{j}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8838;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &#8746;{j}&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ord_def</span><span>
</span><span>            </span><span>Transset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(j)&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8838;succ(j)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=succ(j)&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le} &#8838;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Finite_cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;nat. Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le}) &#10230; Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>ind_on_nat</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;t. Finite({n&#8712;nat. &#10216;n,t&#10217;&#8712;Le})&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite((restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_image_domain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NresFun</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})=&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}=?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is a topology}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_1_L4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_subspace_imp_compact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>&#120081;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#120081;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#120081;&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;&#120081;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120081; &#8746;{U}&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8713;U&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=?NN`n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8713;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(r&#8804;n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_linear_le</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>thesis</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`t. t&#8712;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;&#120081; &#8746; U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;(&#120081; &#8746; {U})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(T). ?A&#8838;&#8899;M &#10230; (&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is compact in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-?A&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-?A=int(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;?A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;T-?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;int(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-?A&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;U&#8712;Pow(&#8899;T).  y &#8712; int(U) &#10230; (&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; U))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T-?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;&#8899;T-?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;y &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;y &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;&#8899;T-?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;&#8899;T-?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;{?NN`t. t&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8838;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span>nat_into_Ord</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,succ(r)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;N x y. (N:nat&#8594;&#8899;T) &#8743; (&#10216;N, Le&#10217; &#8594;<span class="hidden">&#8681;</span><sub>N</sub> x {in} T) &#8743; (&#10216;N, Le&#10217; &#8594;<span class="hidden">&#8681;</span><sub>N</sub> y {in} T)
      &#10230; x=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;US spaces are also $T_1$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>US_imp_T1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is US}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8800;x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;cl({x})&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;T. y&#8712;U &#10230; x&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cl_inter_neigh</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{x}&#8838;&#8899;T&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;ConstantFunction(nat,x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?N:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>func1_3_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?N)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fun</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Net</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?N,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_3_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#10216;0,n&#10217;&#8712;Le &#10230;?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;n&#8712;nat. &#10216;r,n&#10217;&#8712;Le &#10230;?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?N,Le&#10217; &#8594;<span class="hidden">&#8681;</span><sub>N</sub> x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;int(U)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>Top_2_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_3_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#10216;0,n&#10217;&#8712;Le &#10230;?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;n&#8712;nat. &#10216;r,n&#10217;&#8712;Le &#10230;?N`n&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?N,Le&#10217; &#8594;<span class="hidden">&#8681;</span><sub>N</sub> y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dom</span><span>
</span><span>        </span><span>Top_3_L11</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{x}&#8838;&#8899;T&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl({x})&#8838;{x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl({x})={x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cl_contains_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{x}&#8838;&#8899;T&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_3_L8</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T1_iff_singleton_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Counter-examples&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We need to find counter-examples that prove that this properties
are new ones.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We know that $T_2\Rightarrow loc.T_2\Rightarrow$ anti-hyperconnected $\Rightarrow T_1$
and $T_2\Rightarrow KC\Rightarrow US\Rightarrow T_1$. The question is: What is the relation
between $KC$ or $US$ and, $loc.T_2$ or anti-hyperconnected?&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In the file @{file &quot;Topology_ZF_properties_2.thy&quot;} we built a topological space
which is locally-$T_2$ but no $T_2$. It happends actually that this space is not even US
given the appropiate topology &#8249;T&#8250;.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>locT2_not_US_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{m}&#8713;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{m}{is closed in}T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;nat&#8594;&#8899;T. (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> m) &#8743; m&#8713;N``nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;nat&#8594;&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}). (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> &#8899;T {in} (T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))
    &#8743; (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> m {in} (T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> m&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8713;N``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8838;&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>union_doublepoint_top</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N:nat&#8594;&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(N)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fun</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Net</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;{is a net on}&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>
</span><span>    </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Net2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). m&#8712;int(U) &#10230;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Net2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I&#8712;T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L2</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>doble_point_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T)&#8745;?I&#8712;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}){restricted to}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T)&#8745;?I&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace_double_point</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int((&#8899;T)&#8745;?I)=(&#8899;T)&#8745;?I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;int((&#8899;T)&#8745;?I)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;(&#8899;T)&#8745;?I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;?I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;U&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>doble_point_top</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})). m&#8712;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}) &#10230;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;topology0(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>doble_point_top</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>union_doublepoint_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>con1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> m {in} (T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tt</span><span> </span><span>Net</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I&#8712;T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L2</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>doble_point_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I&#8712;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>VW</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?I=(V-{m})&#8746;{&#8899;T}&#8746;W&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;W&#8712;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>VW</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;int(V)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VW</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. N`s&#8800;m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;V-{m}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;?I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VW</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L1</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>doble_point_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})). &#8899;T&#8712;Interior(U,T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}) &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;&#8899;(T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>union_doublepoint_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> &#8899;T {in} (T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tt</span><span> </span><span>Net</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>con1</span><span> </span><span>fun</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>locT2_not_US_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{m}&#8713;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{m}{is closed in}T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N&#8712;nat&#8594;&#8899;T. (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> m) &#8743; m&#8713;N``nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;((T&#8746;{(U-{m})&#8746;{&#8899;T}&#8746;W. &#10216;U,W&#10217;&#8712;{V&#8712;T. m&#8712;V}&#215;T}){is US})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>locT2_not_US_1</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In particular, we also know that a locally-$T_2$ space doesn&#39;t need to be KC;
since KC$\Rightarrow$US. Also we know that anti-hyperconnected spaces don&#39;t need to be
KC or US, since locally-$T_2\Rightarrow$anti-hyperconnected.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Let&#39;s find a KC space that is not $T_2$, an US space which is not KC
and a $T_1$ space which is not US.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First, let&#39;s prove some lemmas about what relation
is there between this properties under the influence of other ones. This will
help us to find counter-examples.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Anti-compactness ereases the differences between several properties.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>anticompact_KC_equiv_T1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is anti-compact}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&#10231;T{is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KC_imp_T1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;T{is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is compact in}T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;Pow(&#8899;T)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is compact in}(T{restricted to}A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>      </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}A)=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(T{restricted to}A)){is compact in}(T{restricted to}A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;Pow(&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8776;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lesspoll_trans</span><span> </span><span>n_lesspoll_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-(&#8899;T-A)=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-(&#8899;T-A)&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-A&#8712;CoFinite &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T-A&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AS</span><span> </span><span>T1_cocardinal_coarser</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Then if we find an anti-compact and $T_1$ but no $T_2$ space,
there is a counter-example for $KC\Rightarrow T_2$. A counter-example for US doesn&#39;t
need to be KC mustn&#39;t be anti-compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on &#8249;csucc(nat)&#8250; is such a topology.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ is hyperconnected.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cocountable_in_csucc_nat_HConn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is hyperconnected}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V=0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-U&#8826;csucc(nat)&#8744;U=0&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-V&#8826;csucc(nat)&#8744;V=0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-U)&#8746;(csucc(nat)-V)&#8826;csucc(nat)&#8744;U=0&#8744;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>
</span><span>      </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-U)&#8746;(csucc(nat)-V)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-U)&#8746;(csucc(nat)-V)=csucc(nat)-U&#8745;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-U)&#8746;(csucc(nat)-V)=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U=0&#8744;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is hyperconnected}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsHConnected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ is not anti-hyperconnected.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>cocountable_in_csucc_nat_notAntiHConn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;((CoCountable csucc(nat)){is anti-}IsHConnected)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is anti-}IsHConnected&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is hyperconnected}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cocountable_in_csucc_nat_HConn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uni</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable csucc(nat))=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A&#8712;(CoCountable csucc(nat)). A&#8838;&#8899;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>uni</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A&#8712;(CoCountable csucc(nat)). A&#8838;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A&#8712;(CoCountable csucc(nat)). csucc(nat)&#8745;A=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((CoCountable csucc(nat)){restricted to}csucc(nat)){is hyperconnected}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)){is in the spectrum of}IsHConnected&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>antiProperty_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uni</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8818;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HConn_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>lesspoll_trans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span>lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ is not $T_2$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cocountable_in_csucc_nat_noT2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(CoCountable csucc(nat)){is T<span class="hidden">&#8681;</span><sub>2</sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is T<span class="hidden">&#8681;</span><sub>2</sub>}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>antiHC</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is anti-}IsHConnected&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.T2_imp_anti_HConn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cocountable_in_csucc_nat_notAntiHConn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ is $T_1$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cocountable_in_csucc_nat_T1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is T<span class="hidden">&#8681;</span><sub>1</sub>}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cocardinal_is_T1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ is anti-compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cocountable_in_csucc_nat_antiCompact</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is anti-compact}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((CoCountable csucc(nat)){restricted to}A)){is compact in}((CoCountable csucc(nat)){restricted to}A)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((CoCountable csucc(nat)){restricted to}A)=CoCountable (A&#8745;csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subspace_cocardinal</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8745;csucc(nat)=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((CoCountable csucc(nat)){restricted to}A)=CoCountable A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(CoCountable A)){is compact in}(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-{t}&#8838;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-{t}&#8818;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-{t}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>noE</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-{t}){is closed in}(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;A-{t}&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-(A-{t})&#8712;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-(A-{t})={t}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8712;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t&#8712;A. {t}&#8712;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(A)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;U&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{t}&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8838;U&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8712;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;V&#8712;(CoCountable A). t&#8712;V &#8743; V&#8838;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.open_neigh_open</span><span class="delimiter">[</span><span>OF</span><span> </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>
</span><span>          </span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A)&#8838;(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;(CoCountable A)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;Pow(&#8899;(CoCountable A))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A)=(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable A){is anti-compact}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_anti_compact</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable A)=&#8899;Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable A)=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>comp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((CoCountable A){restricted to}(&#8899;(CoCountable A)))){is compact in}((CoCountable A){restricted to}(&#8899;(CoCountable A)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>        </span><span>Compact_is_card_nat</span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A&#8826;csucc(nat))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8776;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_iff_leqpoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8776;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8826;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_eq_trans</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span>
</span><span>        </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8818;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_iff_leqpoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;inj(nat,A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lepoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;f:nat&#8594;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;surj(nat,range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;bij(nat,range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8776;range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8776;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is closed in}(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A&#8745;range(f)){is compact in}(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_closed</span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>comp</span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>int</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8745;range(f)=range(f)&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8745;A=range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is compact in}(CoCountable A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is compact in}((CoCountable A){restricted to}range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>        </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((CoCountable A){restricted to}range(f))=CoCountable (range(f)&#8745;A)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subspace_cocardinal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>int</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((CoCountable A){restricted to}range(f))=CoCountable range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is compact in}(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;range(f)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-{t}&#8838;range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-{t}&#8818;range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-{t}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>noE</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)-{t}){is closed in}(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-{t}&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-(range(f)-{t})&#8712;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)-(range(f)-{t})={t}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8712;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t&#8712;range(f). {t}&#8712;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(range(f))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;U&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{t}&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8838;U&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;{t}&#8712;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;V&#8712;(CoCountable range(f)). t&#8712;V &#8743; V&#8838;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.open_neigh_open</span><span class="delimiter">[</span><span>OF</span><span> </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>
</span><span>          </span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(range(f))&#8838;(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;(CoCountable range(f))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;Pow(&#8899;(CoCountable range(f)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;Pow(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Pow(range(f))=(CoCountable range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable range(f)){is anti-compact}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_anti_compact</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable range(f))=&#8899;Pow(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable range(f))=range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>comp2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((CoCountable range(f)){restricted to}(&#8899;(CoCountable range(f))))){is compact in}((CoCountable range(f)){restricted to}(&#8899;(CoCountable range(f))))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>        </span><span>Compact_is_card_nat</span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span>eqpoll_imp_Finite_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_not_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A&#8712;Pow(&#8899;(CoCountable csucc(nat))). ((&#8899;((CoCountable csucc(nat)) {restricted to} A)) {is compact in} ((CoCountable csucc(nat)) {restricted to} A))
    &#10230; (A{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In conclusion, the cocountable topology defined on &#8249;csucc(nat)&#8250;
is KC but not $T_2$. Also note that is KC but not anti-hyperconnected, hence KC or US
spaces need not to be sober.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cofinite topology on the natural numbers is $T_1$, but
not US.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cofinite_not_US</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;((CoFinite nat){is US})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(CoFinite nat){is US}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;id(nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?N:nat&#8594;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>id_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?N:nat&#8594;&#8899;(CoCardinal(nat,nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?N)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fun</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NET</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?N,Le&#10217;{is a net on}&#8899;(CoCardinal(nat,nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCardinal(nat,nat))=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(&#8899;(CoFinite nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;Interior(U,(CoFinite nat))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(U,(CoFinite nat))&#8712;(CoFinite nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L2</span><span>
</span><span>      </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-Interior(U,(CoFinite nat))&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span>
</span><span>      </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(nat-Interior(U,(CoFinite nat)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_nat_is_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-U&#8838;nat-Interior(U,(CoFinite nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L1</span><span>
</span><span>      </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Finite(nat-U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;IsLinOrder(nat,Le)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IsLinOrder(nat-U,Le)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ord_linear_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-U&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;nat-U=0 &#8744; (&#8704;r&#8712;nat-U. &#10216;r,Maximum(Le,nat-U)&#10217;&#8712;Le)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linord_max_props</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-U&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;Le&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;nat-U&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#8707;r&#8712;nat. &#10216;s,r&#10217;&#8712;Le &#8743; ?N`r&#8713;U&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;r&#8712;nat-U. &#10216;r,Maximum(Le,nat-U)&#10217;&#8712;Le)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-U&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Maximum(Le,nat-U)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linord_max_props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lin</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>fin</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(Maximum(Le,nat-U))&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_succI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#10216;succ(Maximum(Le,nat-U)),r&#10217;&#8712;Le &#8743; ?N`r&#8713;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;succ(Maximum(Le,nat-U)),r&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?N`r&#8713;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?N`r&#8712;nat-U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?N`r,Maximum(Le,nat-U)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,Maximum(Le,nat-U)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>id_conv</span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;succ(Maximum(Le,nat-U))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_trans2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s&#8712;nat. &#8704;r&#8712;nat. &#10216;s,r&#10217;&#8712;Le &#10230; ?N`r&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#8704;U&#8712;Pow(&#8899;(CoFinite nat)). n&#8712;Interior(U,CoFinite nat) &#10230; (&#8707;s&#8712;nat. &#8704;r&#8712;nat. &#10216;s,r&#10217;&#8712;Le &#10230; ?N`r&#8712;U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;&#8899;(CoCardinal(nat,nat)). &#8704;U&#8712;Pow(&#8899;(CoCardinal(nat,nat))). n&#8712;Interior(U,CoCardinal(nat,nat)) &#10230; (&#8707;s&#8712;nat. &#8704;r&#8712;nat. &#10216;s,r&#10217;&#8712;Le &#10230; ?N`r&#8712;U)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;&#8899;(CoCardinal(nat,nat)). (&#10216;?N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> n {in}(CoCardinal(nat,nat)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>topology0_CoCardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span> </span><span>NET</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. (&#10216;?N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> n {in}(CoFinite nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;?N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> 0 {in}(CoFinite nat)) &#8743; (&#10216;?N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> 1 {in}(CoFinite nat)) &#8743; 0&#8800;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;To end, we need a space which is US but no KC. This example
comes from the one point compactification of a $T_2$, anti-compact
and non discrete space. This $T_2$, anti-compact and non discrete space
comes from a construction over the cardinal $\mathbb{N}^+$ or &#8249;csucc(nat)&#8250;.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>extension_pow_top</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){is a topology}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?MP</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{U&#8712;M. U&#8712;Pow(csucc(nat))}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?MN</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{U&#8712;M. U&#8713;Pow(csucc(nat))}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unM</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M=(&#8899;?MP)&#8746;(&#8899;?MN)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8713;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MN</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?MN={U&#8712;M. U&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unMP</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?MP&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?MN=0&#10230;&#8899;M&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unM</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?MN&#8800;0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>MN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{U&#8712;M. U&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}}&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U={csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span>MN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;?MN&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;&#8899;?MN&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SC</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{S&#8712;(CoCountable csucc(nat)). {csucc(nat)}&#8746;S&#8712;M}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unSC</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?SC&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CoCar_is_topology</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{csucc(nat)}&#8746;&#8899;?SC&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=csucc(nat)&#8744;s&#8712;&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;?MN&#8744;(&#8707;S&#8712;?SC. s&#8712;S)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;?MN&#8744;(&#8707;S&#8712;(CoCountable csucc(nat)). {csucc(nat)}&#8746;S&#8712;M &#8743; s&#8712;S)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>MN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;?MN&#8744;(&#8707;S&#8712;(CoCountable csucc(nat)). {csucc(nat)}&#8746;S&#8712;?MN &#8743; s&#8712;S)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;?MN&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;&#8899;?SC&#8838;&#8899;?MN&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;?MN&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8713;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U={csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=csucc(nat)&#8744;s&#8712;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=csucc(nat)&#8744;s&#8712;&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{csucc(nat)}&#8746;&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?MN&#8838;{csucc(nat)}&#8746;&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unMN</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?MN={csucc(nat)}&#8746;&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>unSC</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-&#8899;?SC&#8826;csucc(nat)&#8744;&#8899;?SC=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8712;?SC&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span>
</span><span>          </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}={csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;S&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8838;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S={csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{csucc(nat)}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{csucc(nat)}=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8713;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span> </span><span>U</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8838;&#8899;?SC&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noe</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?SC&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-&#8899;?SC&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(&#8899;?SC &#8746; &#8899;?MP)&#8838;csucc(nat)-&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(&#8899;?SC &#8746; &#8899;?MP)&#8818;csucc(nat)-&#8899;?SC&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(&#8899;?SC &#8746; &#8899;?MP)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_trans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?SC&#8838;&#8899;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unSC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?SC&#8838;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;?SC &#8746; &#8899;?MP)&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unMP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;(&#8899;?SC &#8746; &#8899;?MP)&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>noe</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>unM</span><span> </span><span>unMN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M=({csucc(nat)}&#8746;&#8899;?SC) &#8746; &#8899;?MP&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M={csucc(nat)}&#8746;(&#8899;?SC &#8746; &#8899;?MP)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}). &#8899;M&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>UV</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8713;U&#8744;csucc(nat)&#8713;V&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;Pow(csucc(nat))&#8744;V&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;U&#8743;csucc(nat)&#8712;V&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>SU</span><span> </span><span>SV</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U={csucc(nat)}&#8746;SU&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V={csucc(nat)}&#8746;SV&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SU&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;SV&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UV</span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V={csucc(nat)}&#8746;(SU&#8745;SV)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SU&#8745;SV&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CoCar_is_topology</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SU&#8745;SV&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cocountable_in_csucc_nat_HConn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsHConnected_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}). &#8704;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}). U&#8745;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This topology is defined over $\mathbb{N}^+\cup\{\mathbb{N}^+\}$ or &#8249;csucc(nat)&#8746;{csucc(nat)}&#8250;.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extension_pow_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})=csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})=&#8899;(Pow(csucc(nat))) &#8746; (&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230;=csucc(nat) &#8746; (&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})=csucc(nat) &#8746; (&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoCountable csucc(nat))&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CoCar_is_topology</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;csucc(nat)&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;csucc(nat)&#8838;&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8746;{csucc(nat)}&#8838;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;(&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8800;csucc(nat)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U={csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&#8838;csucc(nat) &#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&#8838;csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This topology has a discrete open subspace.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)=Pow(csucc(nat))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=csucc(nat)&#8745;R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&#8838;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Pow(csucc(nat))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=csucc(nat)&#8745;x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(csucc(nat))&#8838;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This topology is Hausdorff.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>extension_pow_T2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){is T<span class="hidden">&#8681;</span><sub>2</sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8800;B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AB</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8800;B&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8800;csucc(nat)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8800;csucc(nat)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AB</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>RA</span><span> </span><span>RB</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}=csucc(nat)&#8745;RA&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}=csucc(nat)&#8745;RB&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RA&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;RB&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>extension_pow_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AB</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8745;{B}=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}). &#8707;V&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}). A&#8712;U&#8743;B&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=csucc(nat)&#8744;B=csucc(nat)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AB</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A=csucc(nat)&#8743;B&#8800;csucc(nat))&#8744;(B=csucc(nat)&#8743;A&#8800;csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A=csucc(nat)&#8743;B&#8800;csucc(nat)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AB</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lesspoll_trans</span><span> </span><span>n_lesspoll_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}{is closed in}(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{B}&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span>
</span><span>          </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{B}=0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)={B}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lesspoll_trans</span><span> </span><span>n_lesspoll_nat</span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;(csucc(nat)-{B})&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;(csucc(nat)-{B})&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{B}=csucc(nat)&#8745;R&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{B}&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span>extension_pow_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({csucc(nat)}&#8746;(csucc(nat)-{B}))&#8745;{B}=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>mem_not_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U1</span><span> </span><span>U2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}. &#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;B&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A=csucc(nat)&#8743;B&#8800;csucc(nat))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B = csucc(nat) &#8743; A &#8800; csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AB</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lesspoll_trans</span><span> </span><span>n_lesspoll_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}{is closed in}(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{A}&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span>
</span><span>          </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{A}=0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)={A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lesspoll_trans</span><span> </span><span>n_lesspoll_nat</span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;(csucc(nat)-{A})&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8746;(csucc(nat)-{A})&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{A}=csucc(nat)&#8745;R&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span>extension_pow_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>int</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{A}&#8745;({csucc(nat)}&#8746;(csucc(nat)-{A}))=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>mem_not_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8712;{A}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;({csucc(nat)}&#8746;(csucc(nat)-{A}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>int</span><span> </span><span>U1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;{A}&#8743;csucc(nat)&#8712;V&#8743;{A}&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}. &#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;csucc(nat)&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;U. U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&#8743;(&#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;csucc(nat)&#8712;V&#8743;U&#8745;V=0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{A}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bex_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}. &#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;B&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}. &#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;B&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;U&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}. &#8707;V&#8712;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}.
          A&#8712;U&#8743;B&#8712;V&#8743;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isT2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The topology we built is not discrete; i.e., not every set is open.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>extension_pow_notDiscrete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8713;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;S&#8712;(CoCountable csucc(nat))-{0}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}={csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{csucc(nat)}&#8746;S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&#8838;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S={csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{csucc(nat)}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{csucc(nat)}=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The topology we built is anti-compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>extension_pow_antiCompact</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){is anti-compact}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>K</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K&#8838;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}K)){is compact in}((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}K)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K&#8838;csucc(nat) &#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}K))=(csucc(nat) &#8746;{csucc(nat)})&#8745;K&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sub</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat) &#8746;{csucc(nat)})&#8745;K=K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}K))=K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>      </span><span>compact_subspace_imp_compact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K&#8838;csucc(nat)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span> </span><span>comp</span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}Pow(csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}(Pow(csucc(nat)){restricted to}K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>        </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)){restricted to}K)=K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(csucc(nat)){restricted to}K)){is compact in}(Pow(csucc(nat)){restricted to}K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_anti_compact</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(K&#8838;csucc(nat))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sub</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sub</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K-{csucc(nat)}&#8838;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K-{csucc(nat)}&#8826;csucc(nat)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is closed in}(CoCountable csucc(nat))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(K-{csucc(nat)})&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span>
</span><span>          </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(K-{csucc(nat)})=0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)=(K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prec</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)} &#8746;(csucc(nat)-(K-{csucc(nat)}))&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)} &#8746;(csucc(nat)-(K-{csucc(nat)}))=({csucc(nat)} &#8746; csucc(nat))-(K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({csucc(nat)} &#8746; csucc(nat))-(K-{csucc(nat)})&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({csucc(nat)} &#8746; csucc(nat))-(K-{csucc(nat)})&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat) &#8746; {csucc(nat)}={csucc(nat)} &#8746; csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat) &#8746; {csucc(nat)})-(K-{csucc(nat)})&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}))-(K-{csucc(nat)})&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is closed in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>comp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K&#8745;(K-{csucc(nat)})){is compact in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_closed</span><span>
</span><span>          </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K&#8745;(K-{csucc(nat)})=(K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is compact in}((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span> </span><span>comp</span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>          </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))=(K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))){is compact in}(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K-{csucc(nat)}){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_anti_compact</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Diff_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(K-{csucc(nat)}&#8826;csucc(nat))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K-{csucc(nat)}&#8776;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_iff_leqpoll</span><span> </span><span>subset_imp_lepoll</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K-{csucc(nat)}&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8776;K-{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8826;K-{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_eq_trans</span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span>
</span><span>          </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8818;K-{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_iff_leqpoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;inj(nat,K-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lepoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;f:nat&#8594;K-{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;surj(nat,range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#8712;bij(nat,range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&#8776;range(f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8776;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f){is closed in}(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_sets_cocardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span>ss</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(range(f))&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span>
</span><span>          </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>noE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-(range(f))=0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ss</span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)=(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)} &#8746;(csucc(nat)-(range(f)))&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)} &#8746;(csucc(nat)-(range(f)))=({csucc(nat)} &#8746; csucc(nat))-(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({csucc(nat)} &#8746; csucc(nat))-(range(f))&#8712;{{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({csucc(nat)} &#8746; csucc(nat))-(range(f))&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat) &#8746; {csucc(nat)}={csucc(nat)} &#8746; csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat) &#8746; {csucc(nat)})-(range(f))&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}))-(range(f))&#8712;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&#8838;&#8899;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is closed in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>comp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(K&#8745;(range(f))){is compact in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_closed</span><span>
</span><span>          </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K&#8745;(range(f))=(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is compact in}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ss</span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is compact in}((Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(f)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>comp</span><span> </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is compact in}(Pow(csucc(nat)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is compact in}(Pow(csucc(nat)){restricted to}(range(f)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span>
</span><span>          </span><span>Compact_is_card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(Pow(csucc(nat)){restricted to}(range(f)))=(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(Pow(csucc(nat)){restricted to}(range(f)))){is compact in}(Pow(csucc(nat)){restricted to}(range(f)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(range(f)){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pow_anti_compact</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span>func1_1_L5B</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(range(f))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span>eqpoll_imp_Finite_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_not_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K {is in the spectrum of}( &#955;T. (&#8899;T) {is compact in} T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K {is in the spectrum of}( &#955;T. (&#8899;T) {is compact in} T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If a topological space is KC, then its one-point compactification
is US.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>KC_imp_OP_comp_is_US</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is KC}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;({one-point compactification of}T){is US}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N:nat&#8594;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x{in}({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> y{in}({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8800;y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Le directs nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Le_directs_nat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(N)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dir</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NET</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;N,Le&#10217;{is a net on}&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;({one-point compactification of}T)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T &#8746;{&#8899;T}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;T &#8746;{&#8899;T}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;{one-point compactification of}T).
        x &#8712; Interior(U, {one-point compactification of}T) &#10230;
        (&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span>dom</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>op2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;{one-point compactification of}T).
        y &#8712; Interior(U, {one-point compactification of}T) &#10230;
        (&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span>dom</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;T&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n&#8712;nat. &#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T=Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;Pow(&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;domain(fst(&#10216;N, Le&#10217;)). &#8704;m&#8712;domain(fst(&#10216;N, Le&#10217;)). &#10216;t, m&#10217; &#8712; snd(&#10216;N, Le&#10217;) &#10230; fst(&#10216;N, Le&#10217;) ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dir</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;z&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsDirectedSet_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#8707;m&#8712;nat. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?NN</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;. n&#8712;nat}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x, z&#10217; &#8712; ?NN&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y&#39;</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x,y&#39;&#10217;&#8712;?NN&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x z. &#10216;x, z&#10217; &#8712; ?NN &#10230; (&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;&#8712;nat&#215;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN&#8712;Pow(nat&#215;&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span>domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1A</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?NN)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>net2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>intT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(int(U),{one-point compactification of}T)=int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Interior(int(U),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>intT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;int(U))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). x &#8712; int(U)
        &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r, s&#10217; &#8712; Le &#10230; ?NN ` s &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>op_comp_is_top</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dom2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;int(U)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>intT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(int(U),{one-point compactification of}T)=int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;Interior(int(U),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>intT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;int(U))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op2</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). y &#8712; int(U)
        &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r, s&#10217; &#8712; Le &#10230; ?NN ` s &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cony</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> y{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>op_comp_is_top</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dom2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>conx</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KC_imp_US</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AAA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8713;&#8899;T&#8744;y&#8713;&#8899;T&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=&#8899;T&#8744;y=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=&#8899;T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n&#8712;nat. &#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T=Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;Pow(&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;domain(fst(&#10216;N, Le&#10217;)). &#8704;m&#8712;domain(fst(&#10216;N, Le&#10217;)). &#10216;t, m&#10217; &#8712; snd(&#10216;N, Le&#10217;) &#10230; fst(&#10216;N, Le&#10217;) ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dir</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;z&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsDirectedSet_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#8707;m&#8712;nat. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?NN</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;. n&#8712;nat}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x, z&#10217; &#8712; ?NN&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y&#39;</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x,y&#39;&#10217;&#8712;?NN&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x z. &#10216;x, z&#10217; &#8712; ?NN &#10230; (&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;&#8712;nat&#215;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN&#8712;Pow(nat&#215;&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span>domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1A</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?NN)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>net2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;int(U)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>intT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(int(U),{one-point compactification of}T)=int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;Interior(int(U),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>intT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;int(U))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op2</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). y &#8712; int(U)
          &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r, s&#10217; &#8712; Le &#10230; ?NN ` s &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cony</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> y{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span>y</span><span> </span><span>op_comp_is_top</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dom2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{y}&#8746;?NN``nat&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Acov</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;T&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;V&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V=int(V)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;int(V)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cony</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;V&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom2</span><span> </span><span>VT</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NresFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}):{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_fun</span><span>
</span><span>            </span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})&#8712;surj({n&#8712;nat. &#10216;n,r&#10217;&#8712;Le},range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}))&#8818;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_fun_inv_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,0&#10217;&#8712;Le}={0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,0&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,succ(j)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8804;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;j &#8746;{j}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8838;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &#8746;{j}&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ord_def</span><span>
</span><span>                </span><span>Transset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(j)&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8838;succ(j)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=succ(j)&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le} &#8838;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Finite_cons</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;nat. Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le}) &#10230; Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))&quot;</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>ind_on_nat</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;t. Finite({n&#8712;nat. &#10216;n,t&#10217;&#8712;Le})&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite((restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_image_domain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NresFun</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})=&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}=?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is a topology}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_1_L4</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_subspace_imp_compact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>&#120081;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#120081;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#120081;&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;&#120081;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120081; &#8746;{V}&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8713;V&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=?NN`n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8712;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8713;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(r&#8804;n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_linear_le</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>thesis</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>              </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`t. t&#8712;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;&#120081; &#8746; V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;(&#120081; &#8746; {V})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(T). ?A&#8838;&#8899;M &#10230; (&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is compact in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is closed in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8712;{B&#8712;Pow(&#8899;T). B{is compact in}(T)&#8743;B{is closed in}(T)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)=Interior({&#8899;T}&#8746;(&#8899;T-?A),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span> </span><span>op_comp_is_top</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;?A&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n=x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noy</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Interior({&#8899;T}&#8746;(&#8899;T-?A),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)&#8712;Pow(&#8899;({one-point compactification of}T))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;U&#8712;Pow(&#8899;({one-point compactification of}T)).  x &#8712; Interior(U,{one-point compactification of}T) &#10230; (&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; U))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dom</span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; {&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;{?NN`t. t&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8838;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span>nat_into_Ord</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,succ(r)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>AAA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8713;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;y=&#8899;T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n&#8712;nat. &#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T=Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Interior(&#8899;T,{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;Pow(&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_subspace</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;domain(fst(&#10216;N, Le&#10217;)). &#8704;m&#8712;domain(fst(&#10216;N, Le&#10217;)). &#10216;t, m&#10217; &#8712; snd(&#10216;N, Le&#10217;) &#10230; fst(&#10216;N, Le&#10217;) ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; &#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&#8712;nat. &#10216;n,m&#10217;&#8712;Le &#10230; N`m=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dir</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;z&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,z&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsDirectedSet_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>z</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`z=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. &#8707;m&#8712;nat. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?NN</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;. n&#8712;nat}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x, z&#10217; &#8712; ?NN&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y&#39;</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;x,y&#39;&#10217;&#8712;?NN&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x z. &#10216;x, z&#10217; &#8712; ?NN &#10230; (&#8704;y&#39;. &#10216;x,y&#39;&#10217;&#8712;?NN &#10230; z=y&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8712;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#10217;&#8712;nat&#215;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN&#8712;Pow(nat&#215;&#8899;({one-point compactification of}T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span>function_def</span><span> </span><span>domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le)&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;n,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;n,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n&#8712;nat. ?NN`n&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?NN:nat&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1A</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;domain(?NN)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>net2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;{is a net on}&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNet_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(U)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>intT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int(U)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(int(U),{one-point compactification of}T)=int(U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Interior(int(U),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>intT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;int(U))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;U&#8712;Pow(&#8899;T). x &#8712; int(U)
        &#10230; (&#8707;r&#8712;nat. &#8704;s&#8712;nat. &#10216;r, s&#10217; &#8712; Le &#10230; ?NN ` s &#8712; U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cony</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?NN,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x{in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span>op_comp_is_top</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dom2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8746;?NN``nat&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Acov</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;V&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V=int(V)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_2_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;int(V)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cony</span><span> </span><span>VT</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; ?NN`s&#8712;V&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>net2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom2</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NresFun</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}):{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8594;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_fun</span><span>
</span><span>          </span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})&#8712;surj({n&#8712;nat. &#10216;n,r&#10217;&#8712;Le},range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le})))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN,{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}))&#8818;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_fun_inv_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,0&#10217;&#8712;Le}={0}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,0&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;t,succ(j)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8804;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;succ(j)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8838;j &#8746;{j}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8838;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#8712;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &#8746;{j}&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ord_def</span><span>
</span><span>              </span><span>Transset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(j)&#8838;t&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8838;succ(j)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=succ(j)&#8744;t&#8804;j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t&#8712;nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#8712;nat&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8712;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le} &#8838;{n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le} &#8746; {succ(j)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Finite_cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;nat. Finite({n&#8712;nat. &#10216;n,j&#10217;&#8712;Le}) &#10230; Finite({n&#8712;nat. &#10216;n,succ(j)&#10217;&#8712;Le})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range(restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>ind_on_nat</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;t. Finite({n&#8712;nat. &#10216;n,t&#10217;&#8712;Le})&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite((restrict(?NN, {n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}))``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_image_domain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NresFun</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})=&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8745;?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}=?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is a topology}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_1_L4</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}(T{restricted to}?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le}){is compact in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_subspace_imp_compact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Acov</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>&#120081;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#120081;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#120081;&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?NN``{n &#8712; nat . &#10216;n, r&#10217; &#8712; Le})&#8838;&#8899;&#120081;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#120081; &#8746;{V}&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8713;V&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>V</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=?NN`n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n&#8712;V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,n&#10217;&#8713;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(r&#8804;n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_linear_le</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>thesis</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>            </span><span>nat_into_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;n,r&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;{?NN`t. t&#8712;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&#8838;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?NN``{n&#8712;nat. &#10216;n,r&#10217;&#8712;Le}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>&#120081;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;&#120081; &#8746; V&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;(&#120081; &#8746; {V})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M&#8712;Pow(T). ?A&#8838;&#8899;M &#10230; (&#8707;&#120081;&#8712;FinPow(M). ?A&#8838;&#8899;&#120081;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8838;&#8899;(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L6</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is compact in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A{is closed in}(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A&#8712;{B&#8712;Pow(&#8899;T). B{is compact in}(T)&#8743;B{is closed in}(T)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)&#8712;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)=Interior({&#8899;T}&#8746;(&#8899;T-?A),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L3</span><span> </span><span>op_comp_is_top</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;?A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;{?NN`n. n&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span class="string"><span class="delete"><span class="delete">&quot;?NN`n=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noy</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;Interior({&#8899;T}&#8746;(&#8899;T-?A),{one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#8899;T}&#8746;(&#8899;T-?A)&#8712;Pow(&#8899;({one-point compactification of}T))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;U&#8712;Pow(&#8899;({one-point compactification of}T)). y &#8712; Interior(U,{one-point compactification of}T) &#10230; (&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; U))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>dom</span><span> </span><span>topology0.NetConverges_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NET</span><span class="delimiter">]</span><span> </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#8712;nat. &#8704;m&#8712;nat. &#10216;t, m&#10217; &#8712; Le &#10230; N ` m &#8712; {&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;nat. &#10216;r,s&#10217;&#8712;Le &#10230; N`s&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,s&#10217;&#8712;Le&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`m&#8800;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;s,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;m. N`m&#8800;&#8899;T &#8743; &#10216;s,m&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>nat_into_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(&#956; i. N`i&#8800;&#8899;T &#8743; &#10216;s,i&#10217;&#8712;Le)&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;{&#8899;T}&#8746;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;(&#8899;T-?A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;{?NN`t. t&#8712;nat}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?NN``nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_imagedef</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?NN`s&#8712;?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8838;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_explained</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8804;succ(r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span>nat_into_Ord</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;r,succ(r)&#10217;&#8712;Le&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#8712;nat&#8250;</span></span></span><span> </span><span>nat_succI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;N x y. N:nat&#8594;(&#8899;{one-point compactification of}T) &#8743; (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> x{in}({one-point compactification of}T))
    &#8743; (&#10216;N,Le&#10217;&#8594;<span class="hidden">&#8681;</span><sub>N</sub> y{in}({one-point compactification of}T)) &#10230; x=y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsUS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In the one-point compactification of an anti-compact space,
ever subspace that contains the infinite point is compact.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>anti_comp_imp_OP_inf_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is anti-compact}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is compact in}({one-point compactification of}T)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8712;U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is closed in}T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U={&#8899;T}&#8746;(&#8899;T-K)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is compact in}(T{restricted to}K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_imp_compact_subspace</span><span> </span><span>Compact_is_card_nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}K)=&#8899;T&#8745;K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(T{restricted to}K)=K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;(T{restricted to}K)){is compact in}(T{restricted to}K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K{is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsAntiComp_def</span><span>
</span><span>      </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finK</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Finite(K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-U&#8838;(&#8899;T &#8746;{&#8899;T}) -U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>K</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-U&#8838;K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finK</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite(A-U)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-U){is in the spectrum of}(&#955;T. (&#8899;T){is compact in}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_spectrum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(({one-point compactification of}T){restricted to}(A-U))=A-U&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>K</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>op_compact_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(({one-point compactification of}T){restricted to}(A-U)){is a topology}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_1_L4</span><span>
</span><span>      </span><span>op_comp_is_top</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-U){is compact in}(({one-point compactification of}T){restricted to}(A-U))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-U){is compact in}({one-point compactification of}T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compact_subspace_imp_compact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-U&#8838;&#8899;M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;N&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-U&#8838;&#8899;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N &#8746;{U}&#8712;FinPow(M)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>N</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;&#8899;(N &#8746;{U})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;R&#8712;FinPow(M). A&#8838;&#8899;R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>op_compact_total</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsCompact_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;As a last result in this section, the one-point compactification of our topology is not a KC space.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>extension_pow_OP_not_KC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(({one-point compactification of}(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})){is KC})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(csucc(nat)) &#8746; {{csucc(nat)}&#8746;S. S&#8712;(CoCountable csucc(nat))-{0}})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;({one-point compactification of}?T){is KC}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>extension_pow_notDiscrete</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)} &#8713; (Pow(csucc(nat)) &#8746; {{csucc(nat)} &#8746; S . S &#8712; (CoCountable csucc(nat)) - {0}})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)=csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;csucc(nat)&#8746;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;({one-point compactification of}(Pow(csucc(nat)) &#8746; {{csucc(nat)} &#8746; S . S &#8712; (CoCountable csucc(nat)) - {0}}))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8712;{{&#8899;?T}&#8746;((&#8899;?T)-K). K&#8712;{B&#8712;Pow(&#8899;?T). B{is compact in}?T &#8743; B{is closed in}?T}}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>OPCompactification_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_notDiscrete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}={&#8899;?T}&#8746;((&#8899;?T)-K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?T&#8712;{&#8899;?T}&#8746;((&#8899;?T)-K)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?T&#8712;{csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{csucc(nat)}&#8713;({one-point compactification of}?T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;({one-point compactification of}?T)-(&#8899;({one-point compactification of}?T)-{csucc(nat)})={csucc(nat)}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_union</span><span>
</span><span>    </span><span>topology0.op_compact_total</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>di</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;({one-point compactification of}?T)-(&#8899;({one-point compactification of}?T)-{csucc(nat)})&#8713;({one-point compactification of}?T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;({one-point compactification of}?T)-(&#8899;({one-point compactification of}?T)-{csucc(nat)})&#8712;({one-point compactification of}?T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>di</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;((&#8899;({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;?T&#8712;(&#8899;({one-point compactification of}?T)-{csucc(nat)})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.op_compact_total</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_top</span><span>
</span><span>    </span><span>extension_pow_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;({one-point compactification of}?T)-{csucc(nat)}){is compact in}({one-point compactification of}?T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.anti_comp_imp_OP_inf_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?T&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;({one-point compactification of}?T)-{csucc(nat)})&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extension_pow_antiCompact</span><span> </span><span>extension_pow_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsKC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In conclusion, $US\not\Rightarrow KC$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Other types of properties&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section we will define new properties that
aren&#39;t defined as anti-properties and that are not separation axioms.
In some cases we will consider their anti-properties.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definitions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A space is called perfect if it has no isolated points.
This definition may vary in the literature to similar, but not equivalent definitions.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsPerf</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is perfect}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is perfect} &#8801; &#8704;x&#8712;&#8899;T. {x}&#8713;T&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An anti-perfect space is called scattered.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsScatt</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is scattered}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is scattered} &#8801; T{is anti-}IsPerf&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A topological space with two disjoint dense subspaces
is called resolvable.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsRes</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is resolvable}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is resolvable} &#8801; &#8707;U&#8712;Pow(&#8899;T). &#8707;V&#8712;Pow(&#8899;T). Closure(U,T)=&#8899;T &#8743; Closure(V,T)=&#8899;T &#8743; U&#8745;V=0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A topological space where every dense subset is open
is called submaximal.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsSubMax</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is submaximal}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is submaximal} &#8801; &#8704;U&#8712;Pow(&#8899;T). Closure(U,T)=&#8899;T &#10230; U&#8712;T&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A subset of a topological space is nowhere-dense if
the interior of its closure is empty.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsNowhereDense</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is nowhere dense in} _&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;A{is nowhere dense in}T &#8801; A&#8838;&#8899;T &#8743; Interior(Closure(A,T),T)=0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A topological space is then a Luzin space if
every nowhere-dense subset is countable.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsLuzin</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ {is luzin}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is luzin} &#8801; &#8704;A&#8712;Pow(&#8899;T). (A{is nowhere dense in}T) &#10230; A&#8818;nat&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An also useful property is local-connexion.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsLocConn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_{is locally-connected}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is locally-connected} &#8801; T{is locally}(&#955;T. &#955;B. ((T{restricted to}B){is connected}))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An SI-space is an anti-resolvable perfect space.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsAntiRes</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_{is anti-resolvable}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is anti-resolvable} &#8801; T{is anti-}IsRes&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>IsSI</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_{is Strongly Irresolvable}&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;T{is Strongly Irresolvable} &#8801; (T{is anti-resolvable}) &#8743; (T{is perfect})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First examples&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Firstly, we need to compute the spectrum of
the being perfect.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spectrum_perfect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A{is in the spectrum of}IsPerf) &#10231; A=0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsPerf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A){is perfect}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pow_is_top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b&#8712;A. {b}&#8713;Pow(A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>T</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>T</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_0_is_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is perfect}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsPerf&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The discrete space is clearly scattered:&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pow_is_scattered</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A){is scattered}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;Pow(A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Pow(A){restricted to}B){is perfect}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(A){restricted to}B=Pow(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RestrictedTo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pow(B){is perfect}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b&#8712;B. {b}&#8713;Pow(B)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spectrum_perfect</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsScatt_def</span><span> </span><span>antiProperty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The trivial topology is perfect, if it is defined over a set with more than one point.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trivial_is_perfect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x y. x&#8712;X &#8743; y&#8712;X &#8743; x&#8800;y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{0,X}{is perfect}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{r}&#8712;{0,X}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X={r}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The trivial topology is resolvable, if it is defined over a set with more than one point.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trivial_is_resolvable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x y. x&#8712;X &#8743; y&#8712;X &#8743; x&#8800;y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{0,X}{is resolvable}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;X&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;X&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8800;y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is closed in}{0,X}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;X&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X-A&#8712;{0,X}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsClosed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X-A=0&#8744;X-A=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=X&#8744;X-A=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X-A=X&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X-(X-A)=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=X&#8744;A=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=0&#8744;A=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A&#8712;Pow(X). A{is closed in}{0,X} &#10230; A=0&#8744;A=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8745;{y}=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{X}{is a partition of}X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>indiscrete_partition</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>top</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;topology0(PTopology X {X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0_ptopology</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(PTopology X {X})={0,X}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>indiscrete_ptopology</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>top</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>top0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;topology0({0,X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;Closure({x},{0,X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.cl_contains_set</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({x},{0,X}) {is closed in}{0,X}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.cl_is_closed</span><span> </span><span>top0</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({x},{0,X})&#8838;X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_3_L11</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>top0</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({x},{0,X})=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{X}{is a partition of}X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>indiscrete_partition</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>top</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;topology0(PTopology X {X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0_ptopology</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(PTopology X {X})={0,X}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>indiscrete_ptopology</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>top</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>top0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;topology0({0,X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8712;Closure({y},{0,X})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.cl_contains_set</span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({y},{0,X}) {is closed in}{0,X}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.cl_is_closed</span><span> </span><span>top0</span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({y},{0,X})&#8838;X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_3_L11</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>top0</span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure({y},{0,X})=X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsRes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The spectrum of Luzin spaces is the class of countable sets, so there
are lots of examples of Luzin spaces.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spectrum_Luzin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A{is in the spectrum of}IsLuzin) &#10231; A&#8818;nat&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsLuzin&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8800;0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M&#8838;{0,{x},A}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;M&#8712;{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8712;{0,{x},A}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8712;{0,{x},A}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V&#8712;{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>top</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{0,{x},A}{is a topology}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsATopology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;{0,{x},A}=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>luz</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{0,{x},A}{is luzin}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8712;{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#8899;{0,{x},A})-{x}){is closed in}{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_3_L9</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-{x}){is closed in}{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure(A-{x},{0,{x},A})=A-{x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>top</span><span> </span><span>topology0.Top_3_L8</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{0,{x},A}&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})=Interior(A-{x},{0,{x},A})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})&#8838;A-{x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>top</span><span> </span><span>topology0.Top_2_L1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})&#8712;{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_2_L2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>top</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A&#8838;A-{x})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-{x}){is nowhere dense in}{0,{x},A}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNowhereDense_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>luz</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A-{x}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLuzin_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A-{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8776;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A-{x})&#8746;{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A-{x})&#8746;{x}=A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A&#8818;nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>T</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B{is nowhere dense in}T&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8818;&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>T</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8818;A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_eq_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B&#8712;Pow(&#8899;T). (B{is nowhere dense in}T) &#10230; B&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is luzin}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLuzin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsLuzin&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Structural results&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Every resolvable space is also perfect.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>topology0</span><span class="delimiter">)</span><span> </span><span>resolvable_imp_perfect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is resolvable}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is perfect}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(T{is perfect})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8712;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;T-{x}){is closed in}T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Top_3_L9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>UV</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;U&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V&#8838;&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl(U)=&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl(V)=&#8899;T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U&#8745;V=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsRes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>W</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8713;W&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;W&#8838;&#8899;T&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;W&#8838;&#8899;T-{x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl(W)&#8838;&#8899;T-{x}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cl</span><span> </span><span>Top_3_L13</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8899;T&#8838;cl(W))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(cl(W)=&#8899;T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The spectrum of being resolvable follows:&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>spectrum_resolvable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A{is in the spectrum of}IsRes) &#10231; A=0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsRes&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;T. T{is a topology} &#10230; IsRes(T) &#10230; IsPerf(T)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.resolvable_imp_perfect</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsPerf&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_imp_Q_spec_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>IsRes</span><span> </span><span>IsPerf</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spectrum_perfect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;A=0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>T</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;T{is a topology}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>T</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T&#8776;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;T=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_0_is_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure(0,T)=&#8899;T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>topology0.Top_3_L2</span><span> </span><span>T</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span>topology0.Top_3_L8</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>topology0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T{is resolvable}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsRes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A{is in the spectrum of}IsRes&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cofinite space over $\mathbb{N}$ is a $T_1$, perfect and luzin space.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cofinite_nat_perfect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoFinite nat){is perfect}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;(CoFinite nat)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8712;(CoFinite nat)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat-{x}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({x})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat-{x})&#8746;{x}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat-{x})&#8746;{x}=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cofinite_nat_luzin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoFinite nat){is luzin}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat{is in the spectrum of}IsLuzin&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spectrum_Luzin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(CoFinite nat)=nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoFinite nat){is a topology}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cofinite_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CoCar_is_topology</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The cocountable topology on $\mathbb{N}^+$ or &#8249;csucc(nat)&#8250; is also $T_1$,
perfect and luzin; but defined on a set not in the spectrum.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cocountable_csucc_nat_perfect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is perfect}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;&#8899;(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8712;(CoCountable csucc(nat))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span>CoCardinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Finite({x})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8826;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_lesspoll_nat</span><span> </span><span>eq_lesspoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-{x})&#8746;{x}&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_less_imp_un_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_nat</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(csucc(nat)-{x})&#8746;{x}=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsPerf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cocountable_csucc_nat_luzin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CoCountable csucc(nat)){is luzin}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ord_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;B&#8712;Pow(&#8899;(CoCountable csucc(nat)))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B{is nowhere dense in}(CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(B&#8818;nat)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#8838;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_cocardinal</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(B&#8826;csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Closure(B,CoCountable csucc(nat))=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closure_set_cocardinal</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(Closure(B,CoCountable csucc(nat)),CoCountable csucc(nat))=Interior(csucc(nat),CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0=Interior(csucc(nat),CoCountable csucc(nat))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsNowhereDense_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-csucc(nat)=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;csucc(nat)-csucc(nat)&#8826;csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span>Card_less_csucc_eq_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_nat</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Interior(csucc(nat),CoCountable csucc(nat))=csucc(nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interior_set_cocardinal</span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cocountable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>noE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B&#8712;Pow(&#8899;(CoCountable csucc(nat))). (B{is nowhere dense in}(CoCountable csucc(nat))) &#10230; B&#8818;nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsLuzin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The existence of $T_2$, uncountable, perfect and luzin spaces is unprovable in \emph{ZFC}.
It is related to the \emph{CH} and Martin&#39;s axiom.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
