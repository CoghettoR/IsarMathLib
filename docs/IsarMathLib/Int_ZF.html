<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Theory Int_ZF (Isabelle2007: November 2007)</title>
<link rel="stylesheet" type="text/css" href="isabelle.css">
</head>

<body>
<div class="head"><h1>Theory Int_ZF</h1>


<p><a href="index.html">Up</a> to index of Isabelle/ZF/IsarMathLib</p>
<span class="command">theory</span> <span class="name">Int_ZF</span><br>
<span class="keyword">imports</span> <a href="OrderedGroup_ZF.html"><span class="name">OrderedGroup_ZF</span></a> <a href="../Int.html"><span class="name">Int</span></a> <a href="Nat_ZF.html"><span class="name">Nat_ZF</span></a><br>
<span class="keyword">begin</span><br>

</div>
<hr>
<div class="source">
<pre>(* 
    This file is a part of IsarMathLib - 
    a library of formalized mathematics for Isabelle/Isar.

    Copyright (C) 2005, 2006  Slawomir Kolodynski

    This program is free software; Redistribution and use in source and binary forms, 
    with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation and/or 
   other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products 
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*)

header {*\isaheader{Int\_ZF.thy}*}

theory Int_ZF imports OrderedGroup_ZF Finite_ZF_1 Int Nat_ZF 

begin;

text{*This theory file is an interface between the old-style Isabelle 
  (ZF logic) material on integers and the IsarMathLib project. Here we
  redefine the meta-level operations on integers 
  (addition and multiplication) to convert them to ZF-functions and show
  that integers form a commutative group with respect to addition and 
  commutative monoid with respect to multiplication. Similarly, we redefine the
  order on integers as a relation, that is a subset of $Z\times Z$. 
  We show that a subset of intergers is bounded iff it is finite.*}

section{*Addition and multiplication as ZF-functions.*}

text{*In this section we provide definitions of addition and multiplication
  as subsets of $(Z\times Z)\times Z$. We 
  use the $\$\leq $ (higher order) relation defined in the standard 
  @{text "Int"} theory to 
  define a subset of $Z\times Z$ that constitutes the ZF order relation 
  corresponding to it. We define positive integers using the notion of 
  positive set from the @{text "OrderedGroup"} theory.*}

constdefs

  "IntegerAddition &equiv; { &lt;x,c&gt; &isin; (int&times;int)&times;int. fst(x) $+ snd(x) = c}"

  "IntegerMultiplication &equiv; 
    { &lt;x,c&gt; &isin; (int&times;int)&times;int. fst(x) $&times; snd(x) = c}"

  "IntegerOrder &equiv; {p &isin; int&times;int. fst(p) $&le; snd(p)}"

  "PositiveIntegers &equiv; PositiveSet(int,IntegerAddition,IntegerOrder)";

text{*IntegerAddition and IntegerMultiplication are functions on 
  int$\times$int. *}

lemma Int_ZF_1_L1: 
  "IntegerAddition : int&times;int -&gt; int"
  "IntegerMultiplication : int&times;int -&gt; int"
proof -
  have
    "{&lt;x,c&gt; &isin; (int&times;int)&times;int. fst(x) $+ snd(x) = c} &isin; int&times;int-&gt;int" 
    "{&lt;x,c&gt; &isin; (int&times;int)&times;int. fst(x) $&times; snd(x) = c} &isin; int&times;int-&gt;int"
    using func1_1_L11A by auto
  then show "IntegerAddition : int&times;int -&gt; int" 
    "IntegerMultiplication : int&times;int -&gt; int"
    using IntegerAddition_def IntegerMultiplication_def by auto
qed;

text{*The next context (locale) defines notation used for integers.
  We define @{text "\&lt;zero&gt;"} to denote the neutral element of addition, 
  @{text "\&lt;one&gt;"} as the
  unit of the multiplicative monoid. We introduce notation @{text "m\&lt;lsq&gt;n"} 
  for integers and write @{text "m..n"} to denote the integer interval 
  with endpoints in $m$ and $n$. 
  @{text "abs(m)"} means the absolute value of $m$. This is a function
  defined in @{text "OrderedGroup"} that assigns $x$ to itself if $x$ is 
  positive and assigns the opposite of $x$ if $x\leq 0$. 
  Unforunately we cannot 
  use the $|\cdot|$ notation as in the @{text "OrderedGroup"} theory as this 
  notation has been hogged by the standard Isabelle's @{text "Int"} theory.
  The notation @{text "\&lt;sm&gt;A"} where $A$ is a subset of integers means the 
  set $\{-m: m\in A\}$. The symbol @{text "maxf(f,M)"} denotes tha maximum 
  of function $f$ over the set $A$. We also introduce a similar notation
  for the minimum.*}

locale int0 =

  fixes ints ("\&lt;int&gt;")
  defines ints_def [simp]: "\&lt;int&gt; &equiv; int"

  fixes ia (infixl "\&lt;ra&gt;" 69)
  defines ia_def [simp]: "a\&lt;ra&gt;b &equiv; IntegerAddition`&lt;a,b&gt;"

  fixes iminus :: "i=&gt;i" ("\&lt;rm&gt; _" 72)
  defines rminus_def [simp]: "\&lt;rm&gt;a &equiv; GroupInv(\&lt;int&gt;,IntegerAddition)`(a)"

  fixes isub (infixl "\&lt;rs&gt;" 69)
  defines isub_def [simp]: "a\&lt;rs&gt;b &equiv; a\&lt;ra&gt; (\&lt;rm&gt; b)"

  fixes imult (infixl "&middot;" 70)
  defines imult_def [simp]: "a&middot;b &equiv; IntegerMultiplication`&lt;a,b&gt;"

  fixes setneg :: "i=&gt;i" ("\&lt;sm&gt; _" 72)
  defines setneg_def [simp]: "\&lt;sm&gt;A &equiv; GroupInv(\&lt;int&gt;,IntegerAddition)``(A)"

  fixes izero ("\&lt;zero&gt;")
  defines izero_def [simp]: "\&lt;zero&gt; &equiv; TheNeutralElement(\&lt;int&gt;,IntegerAddition)"

  fixes ione ("\&lt;one&gt;")
  defines ione_def [simp]: "\&lt;one&gt; &equiv; TheNeutralElement(\&lt;int&gt;,IntegerMultiplication)"

  fixes itwo ("\&lt;two&gt;")
  defines itwo_def [simp]: "\&lt;two&gt; &equiv; \&lt;one&gt;\&lt;ra&gt;\&lt;one&gt;"
 
  fixes ithree ("\&lt;three&gt;")
  defines itwo_def [simp]: "\&lt;three&gt; &equiv; \&lt;two&gt;\&lt;ra&gt;\&lt;one&gt;"
  
  fixes nonnegative ("\&lt;int&gt;<sup>+</sup>")
  defines nonnegative_def [simp]: 
  "\&lt;int&gt;<sup>+</sup> &equiv; Nonnegative(\&lt;int&gt;,IntegerAddition,IntegerOrder)"

  fixes positive ("\&lt;int&gt;<sub>+</sub>")
  defines positive_def [simp]: 
  "\&lt;int&gt;<sub>+</sub> &equiv; PositiveSet(\&lt;int&gt;,IntegerAddition,IntegerOrder)"

  fixes abs 
  defines abs_def [simp]: 
  "abs(m) &equiv; AbsoluteValue(\&lt;int&gt;,IntegerAddition,IntegerOrder)`(m)"
  
  fixes lesseq (infix "\&lt;lsq&gt;" 60)
  defines lesseq_def [simp]: "m \&lt;lsq&gt; n &equiv; &lang;m,n&rang; &isin; IntegerOrder"

  fixes interval (infix ".." 70)
  defines interval_def [simp]: "m..n &equiv; Interval(IntegerOrder,m,n)"

  fixes maxf
  defines maxf_def [simp]: "maxf(f,A) &equiv; Maximum(IntegerOrder,f``(A))"

  fixes minf
  defines minf_def [simp]: "minf(f,A) &equiv; Minimum(IntegerOrder,f``(A))"

text{*IntegerAddition adds integers and IntegerMultiplication multiplies
  integers. This states that the ZF functions @{text "IntegerAddition"} and
  @{text "IntegerMultiplication"} give the same results as the higher-order
  @{text "$+"} and @{text "$&times;"} defined in the standard @{text "Int"} theory.*}

lemma (in int0) Int_ZF_1_L2: assumes A1: "a &isin; \&lt;int&gt;"  "b &isin; \&lt;int&gt;"
  shows 
  "a\&lt;ra&gt;b = a $+ b"  
  "a&middot;b = a $&times; b"
proof -
  let ?x = "&lt;a,b&gt;"
  let ?c = "a $+ b"
  let ?d = "a $&times; b"
  from A1 have 
    "&lt;?x,?c&gt; &isin; {&lt;x,c&gt; &isin; (\&lt;int&gt;&times;\&lt;int&gt;)&times;\&lt;int&gt;. fst(x) $+ snd(x) = c}"
    "&lt;?x,?d&gt; &isin; {&lt;x,d&gt; &isin; (\&lt;int&gt;&times;\&lt;int&gt;)&times;\&lt;int&gt;. fst(x) $&times; snd(x) = d}"
    by auto;
  then show "a\&lt;ra&gt;b = a $+ b"  "a&middot;b = a $&times; b"
    using IntegerAddition_def IntegerMultiplication_def 
      Int_ZF_1_L1 apply_iff by auto;
qed;
 
text{*Integer addition and multiplication are associative.*}

lemma (in int0) Int_ZF_1_L3: 
  assumes "x&isin;\&lt;int&gt;"  "y&isin;\&lt;int&gt;"  "z&isin;\&lt;int&gt;"
  shows "x\&lt;ra&gt;y\&lt;ra&gt;z = x\&lt;ra&gt;(y\&lt;ra&gt;z)"  "x&middot;y&middot;z = x&middot;(y&middot;z)"
  using prems Int_ZF_1_L2 zadd_assoc zmult_assoc by auto;

text{*Integer addition and multiplication are commutative.*}

lemma (in int0) Int_ZF_1_L4:
  assumes "x&isin;\&lt;int&gt;"  "y&isin;\&lt;int&gt;"
  shows "x\&lt;ra&gt;y = y\&lt;ra&gt;x"  "x&middot;y = y&middot;x"
  using prems Int_ZF_1_L2 zadd_commute zmult_commute 
  by auto;

text{*Zero is neutral for addition and one for multiplication.*}

lemma (in int0) Int_ZF_1_L5: assumes A1:"x&isin;\&lt;int&gt;"
  shows "($# 0) \&lt;ra&gt; x = x &and; x \&lt;ra&gt; ($# 0) = x"
  "($# 1)&middot;x = x &and; x&middot;($# 1) = x"
proof -
  from A1 show "($# 0) \&lt;ra&gt; x = x &and; x \&lt;ra&gt; ($# 0) = x"
    using  Int_ZF_1_L2 zadd_int0 Int_ZF_1_L4 by simp;
  from A1 have "($# 1)&middot;x = x"
    using Int_ZF_1_L2 zmult_int1 by simp;
  with A1 show "($# 1)&middot;x = x &and; x&middot;($# 1) = x"
    using Int_ZF_1_L4 by simp;
qed;
    
text{*Zero is neutral for addition and one for multiplication.*}

lemma (in int0) Int_ZF_1_L6: shows "($# 0)&isin;\&lt;int&gt; &and; 
  (&forall;x&isin;\&lt;int&gt;. ($# 0)\&lt;ra&gt;x = x &and; x\&lt;ra&gt;($# 0) = x)"
  "($# 1)&isin;\&lt;int&gt; &and; 
  (&forall;x&isin;\&lt;int&gt;. ($# 1)&middot;x = x &and; x&middot;($# 1) = x)"
  using Int_ZF_1_L5 by auto;

text{*Integers with addition and integers with multiplication
  form monoids.*}
 
theorem (in int0) Int_ZF_1_T1: shows
  "IsAmonoid(\&lt;int&gt;,IntegerAddition)"
  "IsAmonoid(\&lt;int&gt;,IntegerMultiplication)"
proof -
   have  
    "&exist;e&isin;\&lt;int&gt;. &forall;x&isin;\&lt;int&gt;. e\&lt;ra&gt;x = x &and; x\&lt;ra&gt;e = x"
     "&exist;e&isin;\&lt;int&gt;. &forall;x&isin;\&lt;int&gt;. e&middot;x = x &and; x&middot;e = x"
     using int0.Int_ZF_1_L6 by auto;
   then show "IsAmonoid(\&lt;int&gt;,IntegerAddition)"
     "IsAmonoid(\&lt;int&gt;,IntegerMultiplication)" using 
     IsAmonoid_def IsAssociative_def Int_ZF_1_L1 Int_ZF_1_L3 
     by auto;
qed;

text{*Zero is the neutral element of the integers with addition
  and one is the neutral element of the integers with multiplication.*}

lemma (in int0) Int_ZF_1_L8: "($# 0) = \&lt;zero&gt;"  "($# 1) = \&lt;one&gt;"
proof -;
  have "monoid0(\&lt;int&gt;,IntegerAddition)"
    using Int_ZF_1_T1 monoid0_def by simp;
  moreover have 
    "($# 0)&isin;\&lt;int&gt; &and;
    (&forall;x&isin;\&lt;int&gt;. IntegerAddition`&lang;$# 0,x&rang; = x &and; 
    IntegerAddition`&lang;x ,$# 0&rang; = x)"
    using Int_ZF_1_L6 by auto;
  ultimately have "($# 0) = TheNeutralElement(\&lt;int&gt;,IntegerAddition)"
    by (rule monoid0.group0_1_L4);
  then show "($# 0) = \&lt;zero&gt;" by simp;
  have "monoid0(int,IntegerMultiplication)"
    using Int_ZF_1_T1 monoid0_def by simp;
  moreover have "($# 1) &isin; int &and; 
    (&forall;x&isin;int. IntegerMultiplication`&lang;$# 1, x&rang; = x &and; 
    IntegerMultiplication`&lang;x ,$# 1&rang; = x)"
    using Int_ZF_1_L6 by auto;
  ultimately have
    "($# 1) = TheNeutralElement(int,IntegerMultiplication)"
    by (rule monoid0.group0_1_L4)
  then show  "($# 1) = \&lt;one&gt;" by simp;
qed;

text{*$0$  and $1$, as defined in @{text "int0"} context, are integers.*}

lemma (in int0) Int_ZF_1_L8A: shows "\&lt;zero&gt; &isin; \&lt;int&gt;"  "\&lt;one&gt; &isin; \&lt;int&gt;"
proof -
  have "($# 0) &isin; \&lt;int&gt;"  "($# 1) &isin; \&lt;int&gt;" by auto
  then show "\&lt;zero&gt; &isin; \&lt;int&gt;"  "\&lt;one&gt; &isin; \&lt;int&gt;" using Int_ZF_1_L8 by auto;
qed;

text{*Zero is not one.*}

lemma (in int0) int_zero_not_one: shows "\&lt;zero&gt; &ne; \&lt;one&gt;"
proof -
  have "($# 0) &ne; ($# 1)" by simp
  then show "\&lt;zero&gt; &ne; \&lt;one&gt;" using Int_ZF_1_L8 by simp;
qed;

text{*The set of integers is not empty, of course.*}

lemma (in int0) int_not_empty: shows "\&lt;int&gt; &ne; 0"
  using Int_ZF_1_L8A by auto;

text{*The set of integers has more than just zero in it.*}

lemma (in int0) int_not_trivial: shows "\&lt;int&gt; &ne; {\&lt;zero&gt;}"
  using Int_ZF_1_L8A int_zero_not_one by blast;
  
text{*Each integer has an inverse (in the addition sense).*}

lemma (in int0) Int_ZF_1_L9: assumes A1: "g &isin; \&lt;int&gt;"
  shows "&exist; b&isin;\&lt;int&gt;. g\&lt;ra&gt;b = \&lt;zero&gt;"
proof -
  from A1 have "g\&lt;ra&gt; $-g = \&lt;zero&gt;"
    using Int_ZF_1_L2 Int_ZF_1_L8 by simp;
  thus ?thesis by auto;
qed;

text{*Integers with addition form an abelian group. This also shows
  that we can apply all theorems proven in the proof contexts (locales) 
  that require the assumpion that some pair of sets form a group like 
  locale @{text "group0"}.*}
 
theorem Int_ZF_1_T2: shows
  "IsAgroup(int,IntegerAddition)"
  "IntegerAddition {is commutative on} int"
  "group0(int,IntegerAddition)"
  using int0.Int_ZF_1_T1 int0.Int_ZF_1_L9 IsAgroup_def
  group0_def int0.Int_ZF_1_L4 IsCommutative_def by auto;

text{*What is the additive group inverse in the group of integers?*}

lemma (in int0) Int_ZF_1_L9A: assumes A1: "m&isin;\&lt;int&gt;" 
  shows "$-m = \&lt;rm&gt;m"
proof -; 
   from A1 have "m&isin;int" "$-m &isin; int" "IntegerAddition`&lt;m,$-m&gt; = 
     TheNeutralElement(int,IntegerAddition)"
    using zminus_type Int_ZF_1_L2 Int_ZF_1_L8 by auto;
  then have "$-m = GroupInv(int,IntegerAddition)`(m)"
    using Int_ZF_1_T2 group0.group0_2_L9 by blast;
  then show ?thesis by simp;
qed;

text{*Subtracting integers corresponds to adding the negative.*}

lemma (in int0) Int_ZF_1_L10: assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  shows "m\&lt;rs&gt;n = m $+ $-n"
  using prems Int_ZF_1_T2  group0.inverse_in_group Int_ZF_1_L9A Int_ZF_1_L2
  by simp;

text{*Negative of zero is zero.*}

lemma (in int0) Int_ZF_1_L11: shows "(\&lt;rm&gt;\&lt;zero&gt;) = \&lt;zero&gt;"
  using Int_ZF_1_T2  group0.group_inv_of_one by simp;

text{*A trivial calculation lemma that allows to subtract and add one. *}

lemma Int_ZF_1_L12: 
  assumes "m&isin;int" shows "m $- $#1 $+ $#1 = m"
  using prems eq_zdiff_iff by auto;

text{*A trivial calculation lemma that allows to subtract and add one,
  version with ZF-operation.*}

lemma (in int0) Int_ZF_1_L13: assumes "m&isin;\&lt;int&gt;" 
  shows "(m $- $#1) \&lt;ra&gt; \&lt;one&gt; = m"
  using prems Int_ZF_1_L8A Int_ZF_1_L2 Int_ZF_1_L8 Int_ZF_1_L12
  by simp;

text{*Adding or subtracing one changes integers.*}

lemma (in int0) Int_ZF_1_L14: assumes A1: "m&isin;\&lt;int&gt;" 
  shows 
  "m\&lt;ra&gt;\&lt;one&gt; &ne; m"
  "m\&lt;rs&gt;\&lt;one&gt; &ne; m"
proof -
  { assume "m\&lt;ra&gt;\&lt;one&gt; = m" 
    with A1 have 
      "group0(\&lt;int&gt;,IntegerAddition)"  
      "m&isin;\&lt;int&gt;"  "\&lt;one&gt;&isin;\&lt;int&gt;"
      "IntegerAddition`&lang;m,\&lt;one&gt;&rang; = m" 
      using Int_ZF_1_T2 Int_ZF_1_L8A by auto;
    then have "\&lt;one&gt; = TheNeutralElement(\&lt;int&gt;,IntegerAddition)"
      by (rule group0.group0_2_L7);
    then have False using int_zero_not_one by simp;
  } then show I: "m\&lt;ra&gt;\&lt;one&gt; &ne; m" by auto;
  { from A1 have "m \&lt;rs&gt; \&lt;one&gt; \&lt;ra&gt; \&lt;one&gt; = m"
      using Int_ZF_1_L8A Int_ZF_1_T2 group0.inv_cancel_two
      by simp;
    moreover assume "m\&lt;rs&gt;\&lt;one&gt; = m"
    ultimately have "m \&lt;ra&gt; \&lt;one&gt; = m" by simp;
    with I have False by simp;
  } then show "m\&lt;rs&gt;\&lt;one&gt; &ne; m" by auto;
qed;

text{*If the difference is zero, the integers are equal.*}

lemma (in int0) Int_ZF_1_L15: 
  assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;" and A2: "m\&lt;rs&gt;n = \&lt;zero&gt;"
  shows "m=n" 
proof -
  let ?G = "\&lt;int&gt;"
  let ?f = "IntegerAddition"
  from A1 A2 have
    "group0(?G, ?f)"
    "m &isin; ?G"  "n &isin; ?G"
    "?f`&lang;m, GroupInv(?G, ?f)`(n)&rang; = TheNeutralElement(?G, ?f)"
    using Int_ZF_1_T2 by auto;
  then show "m=n" by (rule group0.group0_2_L11A);
qed;

section{*Integers as an ordered group*}

text{*In this section we define order on integers as a relation, that is a 
  subset of $Z\times Z$ and show that integers form an ordered group.*}

text{*The next lemma interprets the order definition one way. *}

lemma (in int0) Int_ZF_2_L1: 
  assumes A1: "m&isin;\&lt;int&gt;" "n&isin;\&lt;int&gt;" and A2: "m $&le; n"
  shows "m \&lt;lsq&gt; n"
proof -
  from A1 A2 have "&lt;m,n&gt; &isin; {x&isin;\&lt;int&gt;&times;\&lt;int&gt;. fst(x) $&le; snd(x)}" 
    by simp;
  then show ?thesis using IntegerOrder_def by simp;
qed;

text{*The next lemma interprets the definition the other way. *}

lemma (in int0) Int_ZF_2_L1A: assumes A1: "m \&lt;lsq&gt; n" 
  shows "m $&le; n" "m&isin;\&lt;int&gt;" "n&isin;\&lt;int&gt;"
proof -;
  from A1 have "&lt;m,n&gt; &isin; {p&isin;\&lt;int&gt;&times;\&lt;int&gt;. fst(p) $&le; snd(p)}"
    using IntegerOrder_def by simp;
  thus "m $&le; n"  "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;" by auto;
qed;

text{*Integer order is a relation on integers.*}

lemma Int_ZF_2_L1B: "IntegerOrder &sube; int&times;int"
proof;
  fix x assume "x&isin;IntegerOrder" 
  then have "x &isin; {p&isin;int&times;int. fst(p) $&le; snd(p)}"
    using IntegerOrder_def by simp;
  then show "x&isin;int&times;int" by simp;
qed;

text{*The way we define the notion of being bounded below,
  its sufficient for the relation to be on integers for
  all bounded below sets to be subsets of integers.*}

lemma (in int0) Int_ZF_2_L1C: 
  assumes A1: "IsBoundedBelow(A,IntegerOrder)"
  shows "A&sube;\&lt;int&gt;"
proof -
  from A1 have 
    "IntegerOrder &sube; \&lt;int&gt;&times;\&lt;int&gt;"
    "IsBoundedBelow(A,IntegerOrder)"
    using Int_ZF_2_L1B by auto;
  then show "A&sube;\&lt;int&gt;" by (rule Order_ZF_3_L1B);
qed;

text{* The order on integers is reflexive.*}

lemma (in int0) int_ord_is_refl: shows "refl(\&lt;int&gt;,IntegerOrder)"
  using Int_ZF_2_L1 zle_refl refl_def by auto;

text{*The essential condition to show antisymmetry of the order on integers.*}

lemma (in int0) Int_ZF_2_L3: 
  assumes A1: "m \&lt;lsq&gt; n"  "n \&lt;lsq&gt; m"  
  shows "m=n"
proof -;
  from A1 have "m $&le; n"  "n $&le; m"  "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
    using Int_ZF_2_L1A by auto;
  then show "m=n" using zle_anti_sym by auto;
qed;
  
text{*The order on integers is antisymmetric.*}

lemma (in int0) Int_ZF_2_L4: "antisym(IntegerOrder)"
proof -
  have "&forall;m n. m \&lt;lsq&gt; n  &and; n \&lt;lsq&gt; m --&gt; m=n"
    using Int_ZF_2_L3 by auto;
  then show ?thesis using imp_conj antisym_def by simp;
qed;

text{*The essential condition to show that the order on integers is 
  transitive.*}

lemma Int_ZF_2_L5: 
  assumes A1: "&lang;m,n&rang; &isin; IntegerOrder"  "&lang;n,k&rang; &isin; IntegerOrder"
  shows "&lang;m,k&rang; &isin; IntegerOrder"
proof -;
  from A1 have T1: "m $&le; n" "n $&le; k" and T2: "m&isin;int" "k&isin;int"
    using int0.Int_ZF_2_L1A by auto;
  from T1 have "m $&le; k" by (rule zle_trans);
  with T2 show ?thesis using int0.Int_ZF_2_L1 by simp;
qed;

text{*The order on integers is 
  transitive. This version is stated in the @{text "int0"} context 
  using notation for integers.*}

lemma (in int0) Int_order_transitive: 
  assumes A1: "m\&lt;lsq&gt;n"  "n\&lt;lsq&gt;k"
  shows "m\&lt;lsq&gt;k"
proof -
  from A1 have "&lt;m,n&gt; &isin; IntegerOrder"  "&lt;n,k&gt; &isin; IntegerOrder"
    by auto
  then have "&lt;m,k&gt; &isin; IntegerOrder" by (rule Int_ZF_2_L5)
  then show "m\&lt;lsq&gt;k" by simp;
qed;

text{*The order on integers is transitive.*}

lemma Int_ZF_2_L6: "trans(IntegerOrder)"
proof -;
  have "&forall; m n k. 
    &lang;m, n&rang; &isin; IntegerOrder &and; &lang;n, k&rang; &isin; IntegerOrder --&gt; 
    &lang;m, k&rang; &isin; IntegerOrder"
    using Int_ZF_2_L5 by blast;
  then show ?thesis by (rule Fol1_L2);
qed;

text{*The order on integers is a partial order.*}

lemma Int_ZF_2_L7: shows "IsPartOrder(int,IntegerOrder)"
  using int0.int_ord_is_refl int0.Int_ZF_2_L4 
    Int_ZF_2_L6 IsPartOrder_def by simp;

text{*The essential condition to show that the order on integers is 
  preserved by translations. *}

lemma (in int0) int_ord_transl_inv: 
  assumes A1: "k &isin; \&lt;int&gt;" and A2: "m \&lt;lsq&gt; n" 
  shows "m\&lt;ra&gt;k \&lt;lsq&gt; n\&lt;ra&gt;k "  "k\&lt;ra&gt;m\&lt;lsq&gt; k\&lt;ra&gt;n "
proof -;
  from A2 have "m $&le; n" and "m&isin;\&lt;int&gt;" "n&isin;\&lt;int&gt;" 
    using Int_ZF_2_L1A by auto;  
  with A1 show "m\&lt;ra&gt;k \&lt;lsq&gt; n\&lt;ra&gt;k "  "k\&lt;ra&gt;m\&lt;lsq&gt; k\&lt;ra&gt;n "
    using zadd_right_cancel_zle zadd_left_cancel_zle
    Int_ZF_1_L2 Int_ZF_1_L1 apply_funtype
    Int_ZF_1_L2 Int_ZF_2_L1 Int_ZF_1_L2 by auto;
qed;

text{*Integers form a linearly ordered group. We can apply all theorems
  proven in group3 context to integers. *}

theorem (in int0) Int_ZF_2_T1: shows
  "IsAnOrdGroup(\&lt;int&gt;,IntegerAddition,IntegerOrder)"
  "IntegerOrder {is total on} \&lt;int&gt;"
  "group3(\&lt;int&gt;,IntegerAddition,IntegerOrder)"
  "IsLinOrder(\&lt;int&gt;,IntegerOrder)"
proof -;
  have "&forall;k&isin;\&lt;int&gt;. &forall;m n. m \&lt;lsq&gt; n  --&gt; 
    m\&lt;ra&gt;k \&lt;lsq&gt; n\&lt;ra&gt;k &and; k\&lt;ra&gt;m\&lt;lsq&gt; k\&lt;ra&gt;n"
    using int_ord_transl_inv by simp;
  then show T1: "IsAnOrdGroup(\&lt;int&gt;,IntegerAddition,IntegerOrder)" using
    Int_ZF_1_T2 Int_ZF_2_L1B Int_ZF_2_L7 IsAnOrdGroup_def
    by simp;
  then show "group3(\&lt;int&gt;,IntegerAddition,IntegerOrder)"
    using group3_def by simp;
  have "&forall;n&isin;\&lt;int&gt;. &forall;m&isin;\&lt;int&gt;. n\&lt;lsq&gt;m &or; m\&lt;lsq&gt;n"
    using zle_linear Int_ZF_2_L1 by auto;
  then show "IntegerOrder {is total on} \&lt;int&gt;"
    using IsTotal_def by simp;
  with T1 show "IsLinOrder(\&lt;int&gt;,IntegerOrder)"
    using IsAnOrdGroup_def IsPartOrder_def IsLinOrder_def by simp;
qed;

text{*If a pair $(i,m)$ belongs to the order relation on integers and
  $i\neq m$, then $i&lt;m$ in the sense of defined in the standard Isabelle's 
  Int.thy.*}

lemma (in int0) Int_ZF_2_L9: assumes A1: "i \&lt;lsq&gt; m" and A2: "i&ne;m"
  shows "i $&lt; m"
proof -;
  from A1 have "i $&le; m"  "i&isin;\&lt;int&gt;"  "m&isin;\&lt;int&gt;" 
    using Int_ZF_2_L1A by auto;
  with A2 show "i $&lt; m" using zle_def by simp;
qed;

text{*This shows how Isabelle's @{text "$&lt;"} operator translates to IsarMathLib
  notation.*}

lemma (in int0) Int_ZF_2_L9AA: assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  and A2: "m $&lt; n"
  shows "m\&lt;lsq&gt;n"  "m &ne; n"
  using prems zle_def Int_ZF_2_L1 by auto;

text{*A small technical lemma about putting one on the other side
  of an inequality.*}

lemma (in int0) Int_ZF_2_L9A: 
  assumes A1: "k&isin;\&lt;int&gt;" and A2: "m \&lt;lsq&gt; k $- ($# 1)"
  shows "m\&lt;ra&gt;\&lt;one&gt; \&lt;lsq&gt; k"
proof -
  from A2 have "m\&lt;ra&gt;\&lt;one&gt; \&lt;lsq&gt; (k $- ($# 1)) \&lt;ra&gt; \&lt;one&gt;"
    using Int_ZF_1_L8A int_ord_transl_inv by simp;
  with A1 show "m\&lt;ra&gt;\&lt;one&gt; \&lt;lsq&gt; k"
    using Int_ZF_1_L13 by simp;
qed;

text{*We can put any integer on the other side of an inequality reversing
  its sign.*}

lemma (in int0) Int_ZF_2_L9B: assumes "i&isin;\&lt;int&gt;"  "m&isin;\&lt;int&gt;"  "k&isin;\&lt;int&gt;"
  shows "i\&lt;ra&gt;m \&lt;lsq&gt; k  &lt;-&gt; i \&lt;lsq&gt; k\&lt;rs&gt;m"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L9A
  by simp;

text{*A special case of @{text "Int_ZF_2_L9B"} with weaker assumptions.*}

lemma (in int0) Int_ZF_2_L9C: 
  assumes "i&isin;\&lt;int&gt;"  "m&isin;\&lt;int&gt;" and "i\&lt;rs&gt;m \&lt;lsq&gt; k" 
  shows "i \&lt;lsq&gt; k\&lt;ra&gt;m"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L9B
  by simp;
  
text{*Taking (higher order) minus on both sides of inequality reverses it.*}

lemma (in int0) Int_ZF_2_L10: assumes "k \&lt;lsq&gt; i"
  shows 
  "(\&lt;rm&gt;i) \&lt;lsq&gt; (\&lt;rm&gt;k)"   
  "$-i \&lt;lsq&gt; $-k" 
  using prems Int_ZF_2_L1A Int_ZF_1_L9A Int_ZF_2_T1 
    group3.OrderedGroup_ZF_1_L5 by auto;


text{*Taking minus on both sides of inequality reverses it, 
  version with a negative on one side.*}

lemma (in int0) Int_ZF_2_L10AA: assumes "n&isin;\&lt;int&gt;"  "m\&lt;lsq&gt;(\&lt;rm&gt;n)"
  shows "n\&lt;lsq&gt;(\&lt;rm&gt;m)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AD
  by simp;

text{*We can cancel the same element on on both sides of an inequality,
  a version with minus on both sides.*}

lemma (in int0) Int_ZF_2_L10AB: 
  assumes "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"  "k&isin;\&lt;int&gt;" and "m\&lt;rs&gt;n \&lt;lsq&gt; m\&lt;rs&gt;k"
  shows "k\&lt;lsq&gt;n"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AF
  by simp;

text{*If an integer is nonpositive, then its opposite is nonnegative.*}

lemma (in int0) Int_ZF_2_L10A: assumes "k \&lt;lsq&gt; \&lt;zero&gt;"
  shows "\&lt;zero&gt;\&lt;lsq&gt;(\&lt;rm&gt;k)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5A by simp;

text{*If the opposite of an integers is nonnegative, then the integer 
  is nonpositive.*}

lemma (in int0) Int_ZF_2_L10B: 
  assumes "k&isin;\&lt;int&gt;" and "\&lt;zero&gt;\&lt;lsq&gt;(\&lt;rm&gt;k)"
  shows "k\&lt;lsq&gt;\&lt;zero&gt;"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AA by simp;

text{*Adding one to an integer corresponds to taking a successor for a natural
  number.*}

lemma (in int0) Int_ZF_2_L11: "i $+ $# n $+ ($# 1)  =  i $+ $# succ(n)"
proof -
  have "$# succ(n) = $#1 $+ $# n" using int_succ_int_1 by blast;
  then have "i $+ $# succ(n) = i $+ ($# n  $+ $#1)"
    using zadd_commute by simp;
  then show ?thesis using zadd_assoc by simp;
qed;

text{*Adding a natural number increases integers.*}

lemma (in int0) Int_ZF_2_L12: assumes A1: "i&isin;\&lt;int&gt;" and A2: "n&isin;nat"
  shows "i \&lt;lsq&gt; i $+ $#n"
proof (cases "n = 0");
  assume "n = 0" 
  with A1 show "i \&lt;lsq&gt; i $+ $#n" using zadd_int0 int_ord_is_refl refl_def
    by simp;
next;
  assume "n&ne;0" 
  with A2 obtain k where "k&isin;nat" "n = succ(k)" 
    using Nat_ZF_1_L3 by auto;
  with A1 show "i \&lt;lsq&gt; i $+ $#n"
    using zless_succ_zadd zless_imp_zle Int_ZF_2_L1 by simp;
qed;

text{*Adding one increases integers.*}

lemma (in int0) Int_ZF_2_L12A: assumes A1: "j\&lt;lsq&gt;k"
  shows "j \&lt;lsq&gt; k $+ $#1"  "j \&lt;lsq&gt; k\&lt;ra&gt;\&lt;one&gt;"
proof -;
  from A1 have T1:"j&isin;\&lt;int&gt;" "k&isin;\&lt;int&gt;" "j $&le; k" 
    using Int_ZF_2_L1A by auto;  
  moreover from T1 have "k $&le; k $+ $#1" using Int_ZF_2_L12 Int_ZF_2_L1A
    by simp;
  ultimately have "j $&le; k $+ $#1" using zle_trans by fast;
  with T1 show "j \&lt;lsq&gt; k $+ $#1" using Int_ZF_2_L1 by simp;
  with T1 have "j\&lt;lsq&gt; k\&lt;ra&gt;$#1"
    using Int_ZF_1_L2 by simp;
  then show "j \&lt;lsq&gt; k\&lt;ra&gt;\&lt;one&gt;" using Int_ZF_1_L8 by simp;
qed;

text{*Adding one increases integers, yet one more version.*}

lemma (in int0) Int_ZF_2_L12B: assumes A1: "m&isin;\&lt;int&gt;" shows "m \&lt;lsq&gt; m\&lt;ra&gt;\&lt;one&gt;"
  using prems int_ord_is_refl refl_def Int_ZF_2_L12A by simp;

text{*If $k+1 = m+n$, where $n$ is a non-zero natural number, then 
  $m\leq k$. *}

lemma (in int0) Int_ZF_2_L13: 
  assumes A1: "k&isin;\&lt;int&gt;" "m&isin;\&lt;int&gt;" and A2: "n&isin;nat" 
  and A3: "k $+ ($# 1) = m $+ $# succ(n)"
  shows "m \&lt;lsq&gt; k"
proof -;
  from A1 have "k&isin;\&lt;int&gt;" "m $+ $# n &isin; \&lt;int&gt;" by auto;
  moreover from A2 have "k $+ $# 1 = m $+ $# n $+ $#1"
    using Int_ZF_2_L11 by simp;
  ultimately have "k = m $+ $# n" using zadd_right_cancel by simp;
  with A1 A2 show ?thesis using Int_ZF_2_L12 by simp;
qed;

text{*The absolute value of an integer is an integer.*}

lemma (in int0) Int_ZF_2_L14: assumes A1: "m&isin;\&lt;int&gt;"
  shows "abs(m) &isin; \&lt;int&gt;"
proof -;
  have "AbsoluteValue(\&lt;int&gt;,IntegerAddition,IntegerOrder) : \&lt;int&gt;-&gt;\&lt;int&gt;"
    using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L1 by simp;
  with A1 show ?thesis using apply_funtype by simp;
qed;

text{*If two integers are nonnegative, then the opposite
  of one is less or equal than the other and the sum is also nonnegative.*}

lemma (in int0) Int_ZF_2_L14A: 
  assumes "\&lt;zero&gt;\&lt;lsq&gt;m"  "\&lt;zero&gt;\&lt;lsq&gt;n"
  shows 
  "(\&lt;rm&gt;m) \&lt;lsq&gt; n"
  "\&lt;zero&gt; \&lt;lsq&gt; m \&lt;ra&gt; n"
  using prems Int_ZF_2_T1 
    group3.OrderedGroup_ZF_1_L5AC group3.OrderedGroup_ZF_1_L12
  by auto;

text{*We can increase components in an estimate.*}

lemma (in int0) Int_ZF_2_L15: 
  assumes "b\&lt;lsq&gt;b<sub>1</sub>" "c\&lt;lsq&gt;c<sub>1</sub>" and "a\&lt;lsq&gt;b\&lt;ra&gt;c"
  shows "a\&lt;lsq&gt;b<sub>1</sub>\&lt;ra&gt;c<sub>1</sub>"
proof -
  from prems have "group3(\&lt;int&gt;,IntegerAddition,IntegerOrder)" 
    "&lang;a,IntegerAddition`&lt;b,c&gt;&rang; &isin; IntegerOrder" 
    "&lang;b,b<sub>1</sub>&rang; &isin; IntegerOrder" "&lang;c,c<sub>1</sub>&rang; &isin; IntegerOrder"
    using Int_ZF_2_T1 by auto
  then have "&lang;a,IntegerAddition`&lt;b<sub>1</sub>,c<sub>1</sub>&gt;&rang; &isin; IntegerOrder" 
    by (rule group3.OrderedGroup_ZF_1_L5E);
  thus ?thesis by simp;
qed;
 
text{*We can add or subtract the sides of two inequalities.*}

lemma (in int0) int_ineq_add_sides: 
  assumes "a\&lt;lsq&gt;b" and "c\&lt;lsq&gt;d"  
  shows 
  "a\&lt;ra&gt;c \&lt;lsq&gt; b\&lt;ra&gt;d"
  "a\&lt;rs&gt;d \&lt;lsq&gt; b\&lt;rs&gt;c"
  using prems Int_ZF_2_T1 
    group3.OrderedGroup_ZF_1_L5B group3.OrderedGroup_ZF_1_L5I
  by auto;

text{*We can increase the second component in an estimate.*}

lemma (in int0) Int_ZF_2_L15A: 
  assumes "b&isin;\&lt;int&gt;" and "a\&lt;lsq&gt;b\&lt;ra&gt;c" and A3: "c\&lt;lsq&gt;c<sub>1</sub>" 
  shows "a\&lt;lsq&gt;b\&lt;ra&gt;c<sub>1</sub>"
proof - 
  from prems have 
    "group3(\&lt;int&gt;,IntegerAddition,IntegerOrder)" 
    "b &isin; \&lt;int&gt;"
    "&lang;a,IntegerAddition`&lt;b,c&gt;&rang; &isin; IntegerOrder" 
    "&lang;c,c<sub>1</sub>&rang; &isin; IntegerOrder"
    using Int_ZF_2_T1 by auto;
  then have "&lang;a,IntegerAddition`&lt;b,c<sub>1</sub>&gt;&rang; &isin; IntegerOrder" 
     by (rule group3.OrderedGroup_ZF_1_L5D);
   thus ?thesis by simp;
qed;

text{*If we increase the second component in a sum of three
  integers, the whole sum inceases.*}

lemma (in int0) Int_ZF_2_L15C: 
  assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;" and A2: "k \&lt;lsq&gt; L"
  shows "m\&lt;ra&gt;k\&lt;ra&gt;n \&lt;lsq&gt; m\&lt;ra&gt;L\&lt;ra&gt;n"
proof -
  let ?P = "IntegerAddition"
  from prems have
    "group3(int,?P,IntegerOrder)"
    "m &isin; int"  "n &isin; int"
    "&lang;k,L&rang; &isin; IntegerOrder"
    using Int_ZF_2_T1 by auto;
  then have "&lang;?P`&lang;?P`&lt;m,k&gt;,n&rang;, ?P`&lang;?P`&lt;m,L&gt;,n&rang; &rang; &isin; IntegerOrder"
    by (rule group3.OrderedGroup_ZF_1_L10);
  then show "m\&lt;ra&gt;k\&lt;ra&gt;n \&lt;lsq&gt; m\&lt;ra&gt;L\&lt;ra&gt;n" by simp;
qed;

text{*We don't decrease an integer by adding a nonnegative one.*}

lemma (in int0) Int_ZF_2_L15D:
  assumes "\&lt;zero&gt;\&lt;lsq&gt;n"  "m&isin;\&lt;int&gt;"
  shows "m \&lt;lsq&gt; n\&lt;ra&gt;m"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5F
  by simp;

text{*Some inequalities about the sum of two integers
  and its absolute value.*}

lemma (in int0) Int_ZF_2_L15E:
  assumes "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  shows 
  "m\&lt;ra&gt;n \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)"
  "m\&lt;rs&gt;n \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)"
  "(\&lt;rm&gt;m)\&lt;ra&gt;n \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)"
  "(\&lt;rm&gt;m)\&lt;rs&gt;n \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L6A
  by auto;

text{*We can add a nonnegative
  integer to the right hand side of an inequality.*}

lemma (in int0) Int_ZF_2_L15F:  assumes "m\&lt;lsq&gt;k"  and "\&lt;zero&gt;\&lt;lsq&gt;n"
  shows "m \&lt;lsq&gt; k\&lt;ra&gt;n"  "m \&lt;lsq&gt; n\&lt;ra&gt;k"  
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5G
  by auto;

text{*Triangle inequality for integers.*}

lemma (in int0) Int_triangle_ineq: 
  assumes "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  shows "abs(m\&lt;ra&gt;n)\&lt;lsq&gt;abs(m)\&lt;ra&gt;abs(n)"
  using prems Int_ZF_1_T2 Int_ZF_2_T1 group3.OrdGroup_triangle_ineq
  by simp;

text{*Taking absolute value does not change nonnegative integers.*}

lemma (in int0) Int_ZF_2_L16:
  assumes "\&lt;zero&gt;\&lt;lsq&gt;m" shows  "m&isin;\&lt;int&gt;<sup>+</sup>" and "abs(m) = m"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L2 
    group3.OrderedGroup_ZF_3_L2 by auto;

text{*$0\leq 1$, so $|1| = 1$.*}

lemma (in int0) Int_ZF_2_L16A: shows "\&lt;zero&gt;\&lt;lsq&gt;\&lt;one&gt;" and "abs(\&lt;one&gt;) = \&lt;one&gt;"
proof -
  have "($# 0) &isin; \&lt;int&gt;" "($# 1)&isin; \&lt;int&gt;" by auto
  then have "\&lt;zero&gt;\&lt;lsq&gt;\&lt;zero&gt;" and T1: "\&lt;one&gt;&isin;\&lt;int&gt;" 
    using Int_ZF_1_L8 int_ord_is_refl refl_def by auto;
  then have "\&lt;zero&gt;\&lt;lsq&gt;\&lt;zero&gt;\&lt;ra&gt;\&lt;one&gt;" using Int_ZF_2_L12A by simp;
  with T1 show "\&lt;zero&gt;\&lt;lsq&gt;\&lt;one&gt;" using Int_ZF_1_T2 group0.group0_2_L2
    by simp;
  then show "abs(\&lt;one&gt;) = \&lt;one&gt;" using Int_ZF_2_L16 by simp
qed;

text{*$1\leq 2$.*}

lemma (in int0) Int_ZF_2_L16B: shows "\&lt;one&gt;\&lt;lsq&gt;\&lt;two&gt;"
proof -
  have "($# 1)&isin; \&lt;int&gt;" by simp
  then show "\&lt;one&gt;\&lt;lsq&gt;\&lt;two&gt;" 
    using Int_ZF_1_L8 int_ord_is_refl refl_def Int_ZF_2_L12A 
    by simp;
qed;

text{*Integers greater or equal one are greater or equal zero.*}

lemma (in int0) Int_ZF_2_L16C: 
  assumes A1: "\&lt;one&gt;\&lt;lsq&gt;a" shows 
  "\&lt;zero&gt;\&lt;lsq&gt;a"  "a&ne;\&lt;zero&gt;"
  "\&lt;two&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;"
  "\&lt;one&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;"
  "\&lt;zero&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;"
proof -
  from A1 have "\&lt;zero&gt;\&lt;lsq&gt;\&lt;one&gt;" and "\&lt;one&gt;\&lt;lsq&gt;a" 
    using Int_ZF_2_L16A by auto
  then show "\&lt;zero&gt;\&lt;lsq&gt;a" by (rule Int_order_transitive);
  have I: "\&lt;zero&gt;\&lt;lsq&gt;\&lt;one&gt;" using Int_ZF_2_L16A by simp; 
  have "\&lt;one&gt;\&lt;lsq&gt;\&lt;two&gt;" using Int_ZF_2_L16B by simp;
  moreover from A1 show "\&lt;two&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;"
    using Int_ZF_1_L8A int_ord_transl_inv by simp;
  ultimately show "\&lt;one&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;" by (rule Int_order_transitive);
  with I show "\&lt;zero&gt; \&lt;lsq&gt; a\&lt;ra&gt;\&lt;one&gt;" by (rule Int_order_transitive);
  from A1 show "a&ne;\&lt;zero&gt;" using
    Int_ZF_2_L16A Int_ZF_2_L3 int_zero_not_one by auto; 
qed;

text{*Absolute value is the same for an integer and its opposite.*}

lemma (in int0) Int_ZF_2_L17: 
  assumes "m&isin;\&lt;int&gt;" shows "abs(\&lt;rm&gt;m) = abs(m)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L7A by simp;

text{*The absolute value of zero is zero.*}

lemma (in int0) Int_ZF_2_L18: shows "abs(\&lt;zero&gt;) = \&lt;zero&gt;"
  using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L2A by simp;

text{*A different version of the triangle inequality.*}

lemma (in int0) Int_triangle_ineq1: 
  assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  shows 
  "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; abs(n)\&lt;ra&gt;abs(m)"
  "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)"
proof -;
  have "$-n &isin; \&lt;int&gt;" by simp;
  with A1 have "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(\&lt;rm&gt;n)"
    using Int_ZF_1_L9A Int_triangle_ineq by simp;
  with A1 show 
    "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; abs(n)\&lt;ra&gt;abs(m)"
    "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)" 
    using Int_ZF_2_L17 Int_ZF_2_L14 Int_ZF_1_T2 IsCommutative_def
    by auto
qed;

text{*Another version of the triangle inequality.*}

lemma (in int0) Int_triangle_ineq2: 
  assumes "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  and "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; k"
  shows 
  "abs(m) \&lt;lsq&gt; abs(n)\&lt;ra&gt;k"
  "m\&lt;rs&gt;k \&lt;lsq&gt; n"
  "m \&lt;lsq&gt; n\&lt;ra&gt;k"
  "n\&lt;rs&gt;k \&lt;lsq&gt; m"
  using prems Int_ZF_1_T2 Int_ZF_2_T1 
    group3.OrderedGroup_ZF_3_L7D group3.OrderedGroup_ZF_3_L7E
  by auto;

text{*Triangle inequality with three integers. We could use
  @{text "OrdGroup_triangle_ineq3"}, but since simp cannot translate
  the notation directly, it is simpler to reprove it for integers.*}

lemma (in int0) Int_triangle_ineq3: 
  assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"  "k&isin;\&lt;int&gt;"
  shows "abs(m\&lt;ra&gt;n\&lt;ra&gt;k) \&lt;lsq&gt; abs(m)\&lt;ra&gt;abs(n)\&lt;ra&gt;abs(k)"
proof -
  from A1 have T: "m\&lt;ra&gt;n &isin; \&lt;int&gt;"  "abs(k) &isin; \&lt;int&gt;"
    using Int_ZF_1_T2 group0.group_op_closed  Int_ZF_2_L14
    by auto;
  with A1 have "abs(m\&lt;ra&gt;n\&lt;ra&gt;k) \&lt;lsq&gt; abs(m\&lt;ra&gt;n) \&lt;ra&gt; abs(k)"
    using Int_triangle_ineq by simp;
  moreover from A1 T have 
    "abs(m\&lt;ra&gt;n) \&lt;ra&gt; abs(k) \&lt;lsq&gt; abs(m) \&lt;ra&gt; abs(n) \&lt;ra&gt; abs(k)"
    using Int_triangle_ineq int_ord_transl_inv by simp;
  ultimately show ?thesis by (rule Int_order_transitive);
qed;

text{*The next lemma shows what happens when one integers is not
  greater or equal than another.*}
(* trying to use OrderedGroup_ZF_1_L8  results in a longer proof, 
  simp and auto loop here*) 
lemma (in int0) Int_ZF_2_L19: 
  assumes A1: "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;" and A2: "&not;(n\&lt;lsq&gt;m)"
  shows "m\&lt;lsq&gt;n"  "(\&lt;rm&gt;n) \&lt;lsq&gt; (\&lt;rm&gt;m)"  "m&ne;n"
proof -
  from A1 A2 show "m\&lt;lsq&gt;n" using Int_ZF_2_T1 IsTotal_def 
    by auto;
  then show "(\&lt;rm&gt;n) \&lt;lsq&gt; (\&lt;rm&gt;m)" using Int_ZF_2_L10 
    by simp;
  from A1 have "n \&lt;lsq&gt; n" using int_ord_is_refl refl_def 
    by simp;
  with A2 show "m&ne;n" by auto;
qed;

text{*If one integer is greater or equal and not equal to another,
  then it is not smaller or equal.*}

lemma (in int0) Int_ZF_2_L19AA: assumes A1: "m\&lt;lsq&gt;n" and A2: "m&ne;n"
  shows "&not;(n\&lt;lsq&gt;m)"
proof -
  from A1 A2 have 
    "group3(\&lt;int&gt;, IntegerAddition, IntegerOrder)"
    "&lang;m,n&rang; &isin; IntegerOrder"
    "m&ne;n"
    using Int_ZF_2_T1 by auto;
  then have "&lang;n,m&rang; &notin; IntegerOrder" 
    by (rule group3.OrderedGroup_ZF_1_L8AA);
  thus "&not;(n\&lt;lsq&gt;m)" by simp;
qed;

text{*The next lemma allows to prove theorems for the case of positive and 
  negative integers separately.*}

lemma (in int0) Int_ZF_2_L19A: assumes A1: "m&isin;\&lt;int&gt;" and A2: "&not;(\&lt;zero&gt;\&lt;lsq&gt;m)"
  shows "m\&lt;lsq&gt;\&lt;zero&gt;"  "\&lt;zero&gt; \&lt;lsq&gt; (\&lt;rm&gt;m)"  "m&ne;\&lt;zero&gt;"
proof -
  from A1 have T1: "\&lt;zero&gt; &isin; \&lt;int&gt;" 
    using Int_ZF_1_T2 group0.group0_2_L2 by auto;
  with A1 show "m\&lt;lsq&gt;\&lt;zero&gt;" by (rule Int_ZF_2_L19);
  from A1 T1 show "m&ne;\&lt;zero&gt;"  by (rule Int_ZF_2_L19);
  from A1 T1 have "(\&lt;rm&gt;\&lt;zero&gt;)\&lt;lsq&gt;(\&lt;rm&gt;m)" by (rule Int_ZF_2_L19);
  then show "\&lt;zero&gt; \&lt;lsq&gt; (\&lt;rm&gt;m)"
    using Int_ZF_1_T2 group0.group_inv_of_one by simp;
qed;

text{*We can prove a theorem about integers by proving that
  it holds for $m=0$, $m\in$@{text "\&lt;int&gt;<sub>+</sub>"} and $-m\in$@{text "\&lt;int&gt;<sub>+</sub>"}.*}

lemma (in int0) Int_ZF_2_L19B: 
  assumes "m&isin;\&lt;int&gt;" and "Q(\&lt;zero&gt;)" and "&forall;n&isin;\&lt;int&gt;<sub>+</sub>. Q(n)" and "&forall;n&isin;\&lt;int&gt;<sub>+</sub>. Q(\&lt;rm&gt;n)"
  shows "Q(m)"
proof -
  let ?G = "\&lt;int&gt;"
  let ?P = "IntegerAddition"
  let ?r = "IntegerOrder"
  let ?b = "m"
  from prems have 
    "group3(?G, ?P, ?r)"
    "?r {is total on} ?G"
    "?b &isin; ?G"
    "Q(TheNeutralElement(?G, ?P))"
    "&forall;a&isin;PositiveSet(?G, ?P, ?r). Q(a)"
    "&forall;a&isin;PositiveSet(?G, ?P, ?r). Q(GroupInv(?G, ?P)`(a))"
    using Int_ZF_2_T1 by auto;
  then show "Q(?b)" by (rule group3.OrderedGroup_ZF_1_L18);
qed;

text{*An integer is not greater than its absolute value.*}

lemma (in int0) Int_ZF_2_L19C: assumes A1: "m&isin;\&lt;int&gt;"
  shows 
  "m \&lt;lsq&gt; abs(m)"
  "(\&lt;rm&gt;m) \&lt;lsq&gt; abs(m)"
  using prems Int_ZF_2_T1 
    group3.OrderedGroup_ZF_3_L5 group3.OrderedGroup_ZF_3_L6
  by auto;

text{*$|m-n| = |n-m|$.*}

lemma (in int0) Int_ZF_2_L20: assumes "m&isin;\&lt;int&gt;"  "n&isin;\&lt;int&gt;"
  shows "abs(m\&lt;rs&gt;n) = abs(n\&lt;rs&gt;m)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L7B by simp;

text{*We can add the sides of inequalities with absolute values.*}

lemma (in int0) Int_ZF_2_L21: 
  assumes A1: "m&isin;\&lt;int&gt;" "n&isin;\&lt;int&gt;"
  and A2: "abs(m) \&lt;lsq&gt; k"  "abs(n) \&lt;lsq&gt; l"
  shows 
  "abs(m\&lt;ra&gt;n) \&lt;lsq&gt; k \&lt;ra&gt; l"
  "abs(m\&lt;rs&gt;n) \&lt;lsq&gt; k \&lt;ra&gt; l"
  using prems Int_ZF_1_T2 Int_ZF_2_T1 
    group3.OrderedGroup_ZF_3_L7C group3.OrderedGroup_ZF_3_L7CA
  by auto;
  
text{*Absolute value is nonnegative.*}

lemma (in int0) int_abs_nonneg: assumes A1: "m&isin;\&lt;int&gt;"
  shows "abs(m) &isin; \&lt;int&gt;<sup>+</sup>"  "\&lt;zero&gt; \&lt;lsq&gt; abs(m)" 
proof -
  have "AbsoluteValue(\&lt;int&gt;,IntegerAddition,IntegerOrder) : \&lt;int&gt;-&gt;\&lt;int&gt;<sup>+</sup>"
    using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L3C by simp;
  with A1 show "abs(m) &isin; \&lt;int&gt;<sup>+</sup>" using apply_funtype
    by simp;
  then show "\&lt;zero&gt; \&lt;lsq&gt; abs(m)" 
    using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L2 by simp;
qed;

text{*If an nonnegative integer is less or equal than another,
  then so is its absolute value.*}

lemma (in int0) Int_ZF_2_L23: 
  assumes "\&lt;zero&gt;\&lt;lsq&gt;m"   "m\&lt;lsq&gt;k"
  shows "abs(m) \&lt;lsq&gt; k"
  using prems Int_ZF_2_L16 by simp;(* this is probably not worth the effort*)

section{*Induction on integers.*}

text{*In this section we show some induction lemmas for integers. 
  The basic tools are the induction on natural numbers and the fact that
  integers can be written as a sum of a smaller integer and a natural number.
  *}

text{*An integer can be written a a sum of a smaller integer and a natural 
  number.*}

lemma (in int0) Int_ZF_3_L2: assumes A1: "i \&lt;lsq&gt; m"
  shows "&exist;n&isin;nat. m = i $+ $# n"
proof (cases "i=m");
  let ?n = "0"
  assume A2: "i=m"  
  from A1 A2 have "?n &isin; nat" "m = i $+ $# ?n"
    using Int_ZF_2_L1A zadd_int0_right by auto;
  thus "&exist;n&isin;nat. m = i $+ $# n" by blast;
next
  assume A3: "i&ne;m" 
  with A1 have "i $&lt; m" "i&isin;\&lt;int&gt;" "m&isin;\&lt;int&gt;"   
    using Int_ZF_2_L9 Int_ZF_2_L1A by auto;
  then obtain k where D1: "k&isin;nat" "m = i $+ $# succ(k)"
    using zless_imp_succ_zadd_lemma by auto;
  let ?n = "succ(k)"
  from D1 have "?n&isin;nat" "m = i $+ $# ?n" by auto;
  thus "&exist;n&isin;nat. m = i $+ $# n" by simp;
qed;

text{*Induction for integers, the induction step.*}

lemma (in int0) Int_ZF_3_L6: assumes A1: "i&isin;\&lt;int&gt;" 
  and A2: "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m $+ ($# 1))"
  shows "&forall;k&isin;nat. Q(i $+ ($# k)) --&gt; Q(i $+ ($# succ(k)))"
proof;
  fix k assume A3: "k&isin;nat" show "Q(i $+ $# k) --&gt; Q(i $+ $# succ(k))"
  proof;
    assume A4: "Q(i $+ $# k)"
    from A1 A3 have "i\&lt;lsq&gt; i $+ ($# k)" using Int_ZF_2_L12
      by simp;
    with A4 A2 have "Q(i $+ ($# k) $+ ($# 1))" by simp;
    then show "Q(i $+ ($# succ(k)))" using Int_ZF_2_L11 by simp;
  qed
qed;

text{*Induction on integers, version with higher-order increment function.*}

lemma (in int0) Int_ZF_3_L7: 
  assumes A1: "i\&lt;lsq&gt;k" and A2: "Q(i)"
  and A3: "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m $+ ($# 1))"
  shows "Q(k)"
proof -;
  from A1 obtain n where D1: "n&isin;nat" and D2: "k = i $+ $# n"
    using Int_ZF_3_L2 by auto;
  from A1 have T1: "i&isin;\&lt;int&gt;" using Int_ZF_2_L1A by simp;
  from D1 have "n&isin;nat" .
  moreover from A1 have "Q(i $+ $#0)" 
    using Int_ZF_2_L1A zadd_int0 by simp;
  moreover from T1 A3 have 
    "&forall;k&isin;nat. Q(i $+ ($# k)) --&gt; Q(i $+ ($# succ(k)))"
    by (rule Int_ZF_3_L6);
  ultimately have "Q(i $+ ($# n))" by (rule ind_on_nat); 
  with D2 show "Q(k)" by simp;
qed;

text{*Induction on integer, implication between two forms of the induction
  step.*}

lemma (in int0) Int_ZF_3_L7A: assumes 
  A1: "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m\&lt;ra&gt;\&lt;one&gt;)"
  shows "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m $+ ($# 1))"
proof -
  { fix m assume "i\&lt;lsq&gt;m &and; Q(m)" 
    with A1 have T1: "m&isin;\&lt;int&gt;" "Q(m\&lt;ra&gt;\&lt;one&gt;)" using Int_ZF_2_L1A by auto;
    then have "m\&lt;ra&gt;\&lt;one&gt; = m\&lt;ra&gt;($# 1)" using Int_ZF_1_L8 by simp;
    with T1 have "Q(m $+ ($# 1))" using Int_ZF_1_L2
      by simp;
  } then show ?thesis by simp;
qed;

text{*Induction on integers, version with ZF increment function.*}

theorem (in int0) Induction_on_int: 
  assumes A1: "i\&lt;lsq&gt;k" and A2: "Q(i)"
  and A3: "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m\&lt;ra&gt;\&lt;one&gt;)"
  shows "Q(k)"
proof -;
  from A3 have "&forall;m. i\&lt;lsq&gt;m &and; Q(m) --&gt; Q(m $+ ($# 1))"
    by (rule Int_ZF_3_L7A);
  with A1 A2 show ?thesis by (rule Int_ZF_3_L7);
qed;

text{*Another form of induction on integers. This rewrites the basic theorem 
   @{text "Int_ZF_3_L7"} substituting $P(-k)$ for $Q(k)$.*};

lemma (in int0) Int_ZF_3_L7B: assumes A1: "i\&lt;lsq&gt;k" and A2: "P($-i)"
  and A3: "&forall;m. i\&lt;lsq&gt;m &and; P($-m) --&gt; P($-(m $+ ($# 1)))"
  shows "P($-k)"
proof -
  from A1 A2 A3 show "P($-k)" by (rule Int_ZF_3_L7);
qed;

text{*Another induction on integers. This rewrites Int\_ZF\_3\_L7
  substituting $-k$ for $k$ and $-i$ for $i$.*}

lemma (in int0) Int_ZF_3_L8: assumes A1: "k\&lt;lsq&gt;i" and A2: "P(i)" 
  and A3: "&forall;m. $-i\&lt;lsq&gt;m &and; P($-m) --&gt; P($-(m $+ ($# 1)))"
  shows "P(k)"
proof -
  from A1 have T1: "$-i\&lt;lsq&gt;$-k" using Int_ZF_2_L10 by simp;
  from A1 A2 have T2: "P($- $- i)" using Int_ZF_2_L1A zminus_zminus
    by simp;
  from T1 T2 A3 have "P($-($-k))" by (rule Int_ZF_3_L7);
  with A1 show "P(k)" using Int_ZF_2_L1A zminus_zminus by simp;
qed;

text{*An implication between two forms of induction steps.*}

lemma (in int0) Int_ZF_3_L9: assumes A1: "i&isin;\&lt;int&gt;"
  and A2: "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt; P(n $+ $-($#1))"    
  shows "&forall;m. $-i\&lt;lsq&gt;m &and; P($-m) --&gt; P($-(m $+ ($# 1)))"
proof;
  fix m show "$-i\&lt;lsq&gt;m &and; P($-m) --&gt; P($-(m $+ ($# 1)))"
  proof;
    assume A3: "$- i \&lt;lsq&gt; m &and; P($- m)"
    then have "$- i \&lt;lsq&gt; m" by simp;
    then have "$-m \&lt;lsq&gt; $- ($- i)" by (rule Int_ZF_2_L10);
    with A1 A2 A3 show "P($-(m $+ ($# 1)))"
      using zminus_zminus zminus_zadd_distrib by simp;
  qed;
qed;

text{*Backwards induction on integers, version with higher-order decrement
  function.*}

lemma (in int0) Int_ZF_3_L9A: assumes A1: "k\&lt;lsq&gt;i" and A2: "P(i)" 
  and A3: "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt;P(n $+ $-($#1)) "
  shows "P(k)"
proof -
  from A1 have T1: "i&isin;\&lt;int&gt;" using Int_ZF_2_L1A by simp;
  from T1 A3 have T2: "&forall;m. $-i\&lt;lsq&gt;m &and; P($-m) --&gt; P($-(m $+ ($# 1)))"
    by (rule Int_ZF_3_L9);
  from A1 A2 T2 show "P(k)" by (rule Int_ZF_3_L8)
qed;

text{*Induction on integers, implication between two forms of the induction
  step.*}

lemma (in int0) Int_ZF_3_L10: assumes
  A1: "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt; P(n\&lt;rs&gt;\&lt;one&gt;)"
  shows "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt; P(n $+ $-($#1))"
proof -;
  { fix n assume "n\&lt;lsq&gt;i &and; P(n)"
    with A1 have T1: "n&isin;\&lt;int&gt;" "P(n\&lt;rs&gt;\&lt;one&gt;)" using Int_ZF_2_L1A by auto;
    then have "n\&lt;rs&gt;\&lt;one&gt; = n\&lt;rs&gt;($# 1)" using Int_ZF_1_L8 by simp;
    with T1 have "P(n $+ $-($#1))" using Int_ZF_1_L10 by simp
  } then show ?thesis by simp;
qed;

text{*Backwards induction on integers.*}

theorem (in int0) Back_induct_on_int: 
  assumes A1: "k\&lt;lsq&gt;i" and A2: "P(i)" 
  and A3: "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt; P(n\&lt;rs&gt;\&lt;one&gt;)"
  shows "P(k)"
proof -;
  from A3 have "&forall;n. n\&lt;lsq&gt;i &and; P(n) --&gt; P(n $+ $-($#1))"
    by (rule Int_ZF_3_L10);
  with A1 A2 show "P(k)" by (rule Int_ZF_3_L9A);
qed;
    
section{*Bounded vs. finite subsets of integers*}

text{*The goal of this section is to establish that a subset of integers 
  is bounded is and only is it is finite. The fact that all finite sets 
  are bounded is already shown for all linearly ordered groups in 
  @{text "OrderedGroups_ZF.thy"}. To show the other implication we
  show that all intervals starting at 0 are finite and then use a result from
  @{text "OrderedGroups_ZF.thy"}.*}

text{*There are no integers between $k$ and $k+1$.*}

lemma (in int0) Int_ZF_4_L1: 
  assumes A1: "k&isin;\&lt;int&gt;" "m&isin;\&lt;int&gt;" "n&isin;nat" and A2: "k $+ $#1 = m $+ $#n"
  shows "m =  k $+ $#1 &or; m \&lt;lsq&gt; k"
proof (cases "n=0");
  assume "n=0" 
  with A1 A2 show "m =  k $+ $#1 &or; m \&lt;lsq&gt; k" 
    using zadd_int0 by simp;
next assume "n&ne;0" 
  with A1 obtain j where D1: "j&isin;nat" "n = succ(j)"
    using Nat_ZF_1_L3 by auto;
  with A1 A2 D1 show "m =  k $+ $#1 &or; m \&lt;lsq&gt; k" 
    using Int_ZF_2_L13 by simp;
qed;

text{*A trivial calculation lemma that allows to subtract and add one. *}

lemma Int_ZF_4_L1A: 
  assumes "m&isin;int" shows "m $- $#1 $+ $#1 = m"
  using prems eq_zdiff_iff by auto;

text{*There are no integers between $k$ and $k+1$, another formulation.*}

lemma (in int0) Int_ZF_4_L1B: assumes A1: "m \&lt;lsq&gt; L"
  shows 
  "m = L &or; m\&lt;ra&gt;\&lt;one&gt; \&lt;lsq&gt; L"
  "m = L &or; m \&lt;lsq&gt; L\&lt;rs&gt;\&lt;one&gt;" 
proof -
  let ?k = "L $- $#1"
  from A1 have T1: "m&isin;\&lt;int&gt;"  "L&isin;\&lt;int&gt;"  "L = ?k $+ $#1" 
    using Int_ZF_2_L1A Int_ZF_4_L1A by auto;
  moreover from A1 obtain n where D1: "n&isin;nat"  "L = m $+ $# n"
    using Int_ZF_3_L2 by auto;
  ultimately have "m = L &or; m \&lt;lsq&gt; ?k"
    using Int_ZF_4_L1 by simp;
  with T1 show "m = L   &or;  m\&lt;ra&gt;\&lt;one&gt; \&lt;lsq&gt; L"
    using Int_ZF_2_L9A by auto;
  with T1 show "m = L &or; m \&lt;lsq&gt; L\&lt;rs&gt;\&lt;one&gt;"
    using Int_ZF_1_L8A Int_ZF_2_L9B by simp;
qed;

text{*If $j\in m..k+1$, then $j\in m..n$ or $j=k+1$.*}

lemma (in int0) Int_ZF_4_L2: assumes A1: "k&isin;\&lt;int&gt;"
  and A2: "j &isin; m..(k $+ $#1)"
  shows "j &isin; m..k &or; j &isin; {k $+ $#1}"
proof -;
  from A2 have T1: "m\&lt;lsq&gt;j" "j\&lt;lsq&gt;(k $+ $#1)" using Order_ZF_2_L1A 
    by auto;
  then have T2: "m&isin;\&lt;int&gt;" "j&isin;\&lt;int&gt;" using Int_ZF_2_L1A by auto; 
  from T1 obtain n where "n&isin;nat" "k $+ $#1 = j $+ $# n"
    using Int_ZF_3_L2 by auto;
  with A1 T1 T2 have "(m\&lt;lsq&gt;j &and; j \&lt;lsq&gt; k) &or; j &isin; {k $+ $#1}"
    using Int_ZF_4_L1 by auto;
  then show ?thesis using Order_ZF_2_L1B by auto;
qed;

text{*Extending an integer interval by one is the same as adding the new 
  endpoint.*}

lemma (in int0) Int_ZF_4_L3: assumes A1: "m\&lt;lsq&gt; k"
  shows "m..(k $+ $#1) = m..k &cup; {k $+ $#1}"
proof;
  from A1 have T1: "m&isin;\&lt;int&gt;" "k&isin;\&lt;int&gt;" using Int_ZF_2_L1A by auto;
  then show "m .. (k $+ $# 1) &sube; m .. k &cup; {k $+ $# 1}"
    using Int_ZF_4_L2 by auto;
  from T1 have "m\&lt;lsq&gt; m" using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L3
    by simp;
  with T1 A1 have "m .. k &sube; m .. (k $+ $# 1)"
    using Int_ZF_2_L12 Int_ZF_2_L6 Order_ZF_2_L3 by simp;
  with T1 A1 show "m..k &cup; {k $+ $#1} &sube; m..(k $+ $#1)"
    using Int_ZF_2_L12A int_ord_is_refl Order_ZF_2_L2 by auto;
qed;

text{*Integer intervals are finite - induction step.*}

lemma (in int0) Int_ZF_4_L4: 
  assumes A1: "i\&lt;lsq&gt;m" and A2: "i..m &isin; Fin(\&lt;int&gt;)"
  shows "i..(m $+ $#1) &isin; Fin(\&lt;int&gt;)"
  using prems Int_ZF_4_L3 by simp;

text{*Integer intervals are finite.*}

lemma (in int0) Int_ZF_4_L5: assumes A1: "i&isin;\&lt;int&gt;" "k&isin;\&lt;int&gt;"
  shows "i..k &isin; Fin(\&lt;int&gt;)"
proof (cases "i\&lt;lsq&gt; k");
  assume A2: "i\&lt;lsq&gt;k"
  moreover from A1 have "i..i &isin; Fin(\&lt;int&gt;)"
    using int_ord_is_refl Int_ZF_2_L4 Order_ZF_2_L4 by simp;
  moreover from A2 have 
    "&forall;m. i\&lt;lsq&gt;m &and; i..m &isin; Fin(\&lt;int&gt;) --&gt; i..(m $+ $#1) &isin; Fin(\&lt;int&gt;)"
    using Int_ZF_4_L4 by simp;
  ultimately show "i..k &isin; Fin(\&lt;int&gt;)" by (rule Int_ZF_3_L7);
next assume "&not; i \&lt;lsq&gt; k"
  then show "i..k &isin; Fin(\&lt;int&gt;)" using Int_ZF_2_L6 Order_ZF_2_L5
    by simp;
qed;

text{*Bounded integer sets are finite.*}

lemma (in int0) Int_ZF_4_L6: assumes A1: "IsBounded(A,IntegerOrder)"
  shows "A &isin; Fin(\&lt;int&gt;)"
proof -;
  have T1: "&forall;m &isin; Nonnegative(\&lt;int&gt;,IntegerAddition,IntegerOrder).
    $#0..m &isin; Fin(\&lt;int&gt;)" 
  proof
    fix m assume "m &isin; Nonnegative(\&lt;int&gt;,IntegerAddition,IntegerOrder)"
    then have "m&isin;\&lt;int&gt;" using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L4E
      by auto;
    then show "$#0..m &isin; Fin(\&lt;int&gt;)" using Int_ZF_4_L5 by simp
  qed;
  have "group3(\&lt;int&gt;,IntegerAddition,IntegerOrder)"
    using Int_ZF_2_T1 by simp;
  moreover from T1 have "&forall;m &isin; Nonnegative(\&lt;int&gt;,IntegerAddition,IntegerOrder).
    Interval(IntegerOrder,TheNeutralElement(\&lt;int&gt;,IntegerAddition),m) 
    &isin; Fin(\&lt;int&gt;)" using Int_ZF_1_L8 by simp;
  moreover from A1 have "IsBounded(A,IntegerOrder)" .;
  ultimately show "A &isin; Fin(\&lt;int&gt;)" by (rule group3.OrderedGroup_ZF_2_T1);
qed;

text{*A subset of integers is bounded iff it is finite.*}

theorem (in int0) Int_bounded_iff_fin: 
  shows "IsBounded(A,IntegerOrder)&lt;-&gt; A&isin;Fin(\&lt;int&gt;)"
  using Int_ZF_4_L6 Int_ZF_2_T1 group3.ord_group_fin_bounded 
  by blast;

(*text{*If $A\cap Z_+$ is finite, then $A$ is bounded above.*}

lemma (in int0) Int_ZF_4_L7: 
  assumes "A&sube;\&lt;int&gt;" and "A &cap; \&lt;int&gt;<sub>+</sub> &isin; Fin(\&lt;int&gt;)"
  shows "IsBoundedAbove(A,IntegerOrder)"
  using prems Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L4
  by simp;*)

text{*The image of an interval by any integer function is
  finite, hence bounded.*}

lemma (in int0) Int_ZF_4_L8: 
  assumes A1: "i&isin;\&lt;int&gt;"  "k&isin;\&lt;int&gt;" and A2: "f:\&lt;int&gt;-&gt;\&lt;int&gt;"
  shows 
  "f``(i..k) &isin; Fin(\&lt;int&gt;)"
  "IsBounded(f``(i..k),IntegerOrder)"
  using prems Int_ZF_4_L5 Finite1_L6A Int_bounded_iff_fin
  by auto;

text{*If for every integer we can find one in $A$ that is greater or equal,
  then $A$ is is not bounded above, hence infinite.*}

lemma (in int0) Int_ZF_4_L9: assumes A1: "&forall;m&isin;\&lt;int&gt;. &exist;k&isin;A. m\&lt;lsq&gt;k"
  shows 
  "&not;IsBoundedAbove(A,IntegerOrder)"
  "A &notin; Fin(\&lt;int&gt;)"
proof -
  have "\&lt;int&gt; &ne; {\&lt;zero&gt;}"
    using Int_ZF_1_L8A int_zero_not_one by blast
  with A1 show 
    "&not;IsBoundedAbove(A,IntegerOrder)"
    "A &notin; Fin(\&lt;int&gt;)"
    using Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L2A
    by auto;
qed;


end</pre>
</div>
<hr>
<div class="theorems">


<h2>Addition and multiplication as ZF-functions.</h2>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L1:</span>
<pre>  <span class="term">IntegerAddition &isin; <span class="const">int</span> <span class="const">&times;</span> <span class="const">int</span> <span class="const">-&gt;</span> <span class="const">int</span></span></pre>
<pre>  <span class="term">IntegerMultiplication &isin; <span class="const">int</span> <span class="const">&times;</span> <span class="const">int</span> <span class="const">-&gt;</span> <span class="const">int</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L2:</span>
<pre>  <span class="term">[| <span class="var">a</span> &isin; \&lt;int&gt;; <span class="var">b</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">a</span> \&lt;ra&gt; <span class="var">b</span> = <span class="var">a</span> <span class="const">$+</span> <span class="var">b</span></span></pre>
<pre>  <span class="term">[| <span class="var">a</span> &isin; \&lt;int&gt;; <span class="var">b</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">a</span> &middot; <span class="var">b</span> = <span class="var">a</span> <span class="const">$&times;</span> <span class="var">b</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L3:</span>
<pre>  <span class="term">[| <span class="var">x</span> &isin; \&lt;int&gt;; <span class="var">y</span> &isin; \&lt;int&gt;; <span class="var">z</span> &isin; \&lt;int&gt; |]
  ==&gt; <span class="var">x</span> \&lt;ra&gt; <span class="var">y</span> \&lt;ra&gt; <span class="var">z</span> = <span class="var">x</span> \&lt;ra&gt; (<span class="var">y</span> \&lt;ra&gt; <span class="var">z</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">x</span> &isin; \&lt;int&gt;; <span class="var">y</span> &isin; \&lt;int&gt;; <span class="var">z</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">x</span> &middot; <span class="var">y</span> &middot; <span class="var">z</span> = <span class="var">x</span> &middot; (<span class="var">y</span> &middot; <span class="var">z</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L4:</span>
<pre>  <span class="term">[| <span class="var">x</span> &isin; \&lt;int&gt;; <span class="var">y</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">x</span> \&lt;ra&gt; <span class="var">y</span> = <span class="var">y</span> \&lt;ra&gt; <span class="var">x</span></span></pre>
<pre>  <span class="term">[| <span class="var">x</span> &isin; \&lt;int&gt;; <span class="var">y</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">x</span> &middot; <span class="var">y</span> = <span class="var">y</span> &middot; <span class="var">x</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L5:</span>
<pre>  <span class="term"><span class="var">x</span> &isin; \&lt;int&gt; ==&gt; <span class="const">$#</span> 0 \&lt;ra&gt; <span class="var">x</span> = <span class="var">x</span> &and; <span class="var">x</span> \&lt;ra&gt; <span class="const">$#</span> 0 = <span class="var">x</span></span></pre>
<pre>  <span class="term"><span class="var">x</span> &isin; \&lt;int&gt; ==&gt; <span class="const">$#</span> <span class="const">1</span> &middot; <span class="var">x</span> = <span class="var">x</span> &and; <span class="var">x</span> &middot; <span class="const">$#</span> <span class="const">1</span> = <span class="var">x</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L6:</span>
<pre>  <span class="term"><span class="const">$#</span> 0 &isin; \&lt;int&gt; &and; (&forall;<span class="bound">x</span>&isin;\&lt;int&gt;. <span class="const">$#</span> 0 \&lt;ra&gt; <span class="bound">x</span> = <span class="bound">x</span> &and; <span class="bound">x</span> \&lt;ra&gt; <span class="const">$#</span> 0 = <span class="bound">x</span>)</span></pre>
<pre>  <span class="term"><span class="const">$#</span> <span class="const">1</span> &isin; \&lt;int&gt; &and; (&forall;<span class="bound">x</span>&isin;\&lt;int&gt;. <span class="const">$#</span> <span class="const">1</span> &middot; <span class="bound">x</span> = <span class="bound">x</span> &and; <span class="bound">x</span> &middot; <span class="const">$#</span> <span class="const">1</span> = <span class="bound">x</span>)</span></pre></p>

<p><span class="command">theorem</span> <span class="name">Int_ZF_1_T1:</span>
<pre>  <span class="term"><span class="const">IsAmonoid</span>(\&lt;int&gt;, IntegerAddition)</span></pre>
<pre>  <span class="term"><span class="const">IsAmonoid</span>(\&lt;int&gt;, IntegerMultiplication)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L8:</span>
<pre>  <span class="term"><span class="const">$#</span> 0 = \&lt;zero&gt;</span></pre>
<pre>  <span class="term"><span class="const">$#</span> <span class="const">1</span> = \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L8A:</span>
<pre>  <span class="term">\&lt;zero&gt; &isin; \&lt;int&gt;</span></pre>
<pre>  <span class="term">\&lt;one&gt; &isin; \&lt;int&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_zero_not_one:</span>
<pre>  <span class="term">\&lt;zero&gt; <span class="const">&ne;</span> \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_not_empty:</span>
<pre>  <span class="term">\&lt;int&gt; <span class="const">&ne;</span> 0</span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_not_trivial:</span>
<pre>  <span class="term">\&lt;int&gt; <span class="const">&ne;</span> {\&lt;zero&gt;}</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L9:</span>
<pre>  <span class="term"><span class="var">g</span> &isin; \&lt;int&gt; ==&gt; &exist;<span class="bound">b</span>&isin;\&lt;int&gt;. <span class="var">g</span> \&lt;ra&gt; <span class="bound">b</span> = \&lt;zero&gt;</span></pre></p>

<p><span class="command">theorem</span> <span class="name">Int_ZF_1_T2:</span>
<pre>  <span class="term"><span class="const">IsAgroup</span>(<span class="const">int</span>, IntegerAddition)</span></pre>
<pre>  <span class="term">IntegerAddition <span class="const">{is</span> <span class="const">commutative</span> <span class="const">on}</span> <span class="const">int</span></span></pre>
<pre>  <span class="term"><span class="const">group0</span>(<span class="const">int</span>, IntegerAddition)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L9A:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="const">$-</span> <span class="var">m</span> = \&lt;rm&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L10:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">m</span> \&lt;rs&gt; <span class="var">n</span> = <span class="var">m</span> <span class="const">$+</span> <span class="const">$-</span> <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L11:</span>
<pre>  <span class="term">\&lt;rm&gt; \&lt;zero&gt; = \&lt;zero&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L12:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; <span class="const">int</span> ==&gt; <span class="var">m</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> = <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L13:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; (<span class="var">m</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span>) \&lt;ra&gt; \&lt;one&gt; = <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L14:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="var">m</span> \&lt;ra&gt; \&lt;one&gt; <span class="const">&ne;</span> <span class="var">m</span></span></pre>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="var">m</span> \&lt;rs&gt; \&lt;one&gt; <span class="const">&ne;</span> <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_1_L15:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;rs&gt; <span class="var">n</span> = \&lt;zero&gt; |] ==&gt; <span class="var">m</span> = <span class="var">n</span></span></pre></p>


<h2>Integers as an ordered group</h2>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L1:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">m</span> <span class="const">$&le;</span> <span class="var">n</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L1A:</span>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> ==&gt; <span class="var">m</span> <span class="const">$&le;</span> <span class="var">n</span></span></pre>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> ==&gt; <span class="var">m</span> &isin; \&lt;int&gt;</span></pre>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> ==&gt; <span class="var">n</span> &isin; \&lt;int&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L1B:</span>
<pre>  <span class="term">IntegerOrder &sube; <span class="const">int</span> <span class="const">&times;</span> <span class="const">int</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L1C:</span>
<pre>  <span class="term">IsBoundedBelow(<span class="var">A</span>, IntegerOrder) ==&gt; <span class="var">A</span> &sube; \&lt;int&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_ord_is_refl:</span>
<pre>  <span class="term"><span class="const">refl</span>(\&lt;int&gt;, IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L3:</span>
<pre>  <span class="term">[| <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span>; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; <span class="var">m</span> = <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L4:</span>
<pre>  <span class="term"><span class="const">antisym</span>(IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L5:</span>
<pre>  <span class="term">[| &lang;<span class="var">m</span>, <span class="var">n</span>&rang; &isin; IntegerOrder; &lang;<span class="var">n</span>, <span class="var">k</span>&rang; &isin; IntegerOrder |] ==&gt; &lang;<span class="var">m</span>, <span class="var">k</span>&rang; &isin; IntegerOrder</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_order_transitive:</span>
<pre>  <span class="term">[| <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span>; <span class="var">n</span> \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L6:</span>
<pre>  <span class="term"><span class="const">trans</span>(IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L7:</span>
<pre>  <span class="term">IsPartOrder(<span class="const">int</span>, IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_ord_transl_inv:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">k</span> \&lt;lsq&gt; <span class="var">n</span> \&lt;ra&gt; <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">n</span></span></pre></p>

<p><span class="command">theorem</span> <span class="name">Int_ZF_2_T1:</span>
<pre>  <span class="term"><span class="const">IsAnOrdGroup</span>(\&lt;int&gt;, IntegerAddition, IntegerOrder)</span></pre>
<pre>  <span class="term">IntegerOrder {is total on} \&lt;int&gt;</span></pre>
<pre>  <span class="term"><span class="const">group3</span>(\&lt;int&gt;, IntegerAddition, IntegerOrder)</span></pre>
<pre>  <span class="term">IsLinOrder(\&lt;int&gt;, IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L9:</span>
<pre>  <span class="term">[| <span class="var">i</span> \&lt;lsq&gt; <span class="var">m</span>; <span class="var">i</span> <span class="const">&ne;</span> <span class="var">m</span> |] ==&gt; <span class="var">i</span> <span class="const">$&lt;</span> <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L9AA:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">m</span> <span class="const">$&lt;</span> <span class="var">n</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">m</span> <span class="const">$&lt;</span> <span class="var">n</span> |] ==&gt; <span class="var">m</span> <span class="const">&ne;</span> <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L9A:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span> |] ==&gt; <span class="var">m</span> \&lt;ra&gt; \&lt;one&gt; \&lt;lsq&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L9B:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt; |]
  ==&gt; <span class="var">i</span> \&lt;ra&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> &lt;-&gt; <span class="var">i</span> \&lt;lsq&gt; <span class="var">k</span> \&lt;rs&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L9C:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">i</span> \&lt;rs&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="var">i</span> \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L10:</span>
<pre>  <span class="term"><span class="var">k</span> \&lt;lsq&gt; <span class="var">i</span> ==&gt; \&lt;rm&gt; <span class="var">i</span> \&lt;lsq&gt; \&lt;rm&gt; <span class="var">k</span></span></pre>
<pre>  <span class="term"><span class="var">k</span> \&lt;lsq&gt; <span class="var">i</span> ==&gt; <span class="const">$-</span> <span class="var">i</span> \&lt;lsq&gt; <span class="const">$-</span> <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L10AA:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;lsq&gt; \&lt;rm&gt; <span class="var">n</span> |] ==&gt; <span class="var">n</span> \&lt;lsq&gt; \&lt;rm&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L10AB:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> \&lt;rs&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> \&lt;rs&gt; <span class="var">k</span> |]
  ==&gt; <span class="var">k</span> \&lt;lsq&gt; <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L10A:</span>
<pre>  <span class="term"><span class="var">k</span> \&lt;lsq&gt; \&lt;zero&gt; ==&gt; \&lt;zero&gt; \&lt;lsq&gt; \&lt;rm&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L10B:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; \&lt;zero&gt; \&lt;lsq&gt; \&lt;rm&gt; <span class="var">k</span> |] ==&gt; <span class="var">k</span> \&lt;lsq&gt; \&lt;zero&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L11:</span>
<pre>  <span class="term"><span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> <span class="var">n</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> = <span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> succ(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L12:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">i</span> \&lt;lsq&gt; <span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L12A:</span>
<pre>  <span class="term"><span class="var">j</span> \&lt;lsq&gt; <span class="var">k</span> ==&gt; <span class="var">j</span> \&lt;lsq&gt; <span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span></span></pre>
<pre>  <span class="term"><span class="var">j</span> \&lt;lsq&gt; <span class="var">k</span> ==&gt; <span class="var">j</span> \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L12B:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">m</span> \&lt;ra&gt; \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L13:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> = <span class="var">m</span> <span class="const">$+</span> <span class="const">$#</span> succ(<span class="var">n</span>) |]
  ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L14:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="free">abs</span>(<span class="var">m</span>) &isin; \&lt;int&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L14A:</span>
<pre>  <span class="term">[| \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span>; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; \&lt;rm&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span></span></pre>
<pre>  <span class="term">[| \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span>; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15:</span>
<pre>  <span class="term">[| <span class="var">b</span> \&lt;lsq&gt; <span class="var">b<sub>1</sub></span>; <span class="var">c</span> \&lt;lsq&gt; <span class="var">c<sub>1</sub></span>; <span class="var">a</span> \&lt;lsq&gt; <span class="var">b</span> \&lt;ra&gt; <span class="var">c</span> |] ==&gt; <span class="var">a</span> \&lt;lsq&gt; <span class="var">b<sub>1</sub></span> \&lt;ra&gt; <span class="var">c<sub>1</sub></span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_ineq_add_sides:</span>
<pre>  <span class="term">[| <span class="var">a</span> \&lt;lsq&gt; <span class="var">b</span>; <span class="var">c</span> \&lt;lsq&gt; <span class="var">d</span> |] ==&gt; <span class="var">a</span> \&lt;ra&gt; <span class="var">c</span> \&lt;lsq&gt; <span class="var">b</span> \&lt;ra&gt; <span class="var">d</span></span></pre>
<pre>  <span class="term">[| <span class="var">a</span> \&lt;lsq&gt; <span class="var">b</span>; <span class="var">c</span> \&lt;lsq&gt; <span class="var">d</span> |] ==&gt; <span class="var">a</span> \&lt;rs&gt; <span class="var">d</span> \&lt;lsq&gt; <span class="var">b</span> \&lt;rs&gt; <span class="var">c</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15A:</span>
<pre>  <span class="term">[| <span class="var">b</span> &isin; \&lt;int&gt;; <span class="var">a</span> \&lt;lsq&gt; <span class="var">b</span> \&lt;ra&gt; <span class="var">c</span>; <span class="var">c</span> \&lt;lsq&gt; <span class="var">c<sub>1</sub></span> |] ==&gt; <span class="var">a</span> \&lt;lsq&gt; <span class="var">b</span> \&lt;ra&gt; <span class="var">c<sub>1</sub></span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15C:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">k</span> \&lt;lsq&gt; <span class="var">L</span> |]
  ==&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">L</span> \&lt;ra&gt; <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15D:</span>
<pre>  <span class="term">[| \&lt;zero&gt; \&lt;lsq&gt; <span class="var">n</span>; <span class="var">m</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> \&lt;ra&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15E:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">m</span> \&lt;rs&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; \&lt;rm&gt; <span class="var">m</span> \&lt;ra&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; \&lt;rm&gt; <span class="var">m</span> \&lt;rs&gt; <span class="var">n</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L15F:</span>
<pre>  <span class="term">[| <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span>; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">n</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span>; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">n</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> \&lt;ra&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_triangle_ineq:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;ra&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L16(1):</span>
<pre>  <span class="term">\&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> ==&gt; <span class="var">m</span> &isin; \&lt;int&gt;<sup>+</sup></span></pre></p>


<p><span class="command">and</span> <span class="name">Int_ZF_2_L16(2):</span>
<pre>  <span class="term">\&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> ==&gt; <span class="free">abs</span>(<span class="var">m</span>) = <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L16A(1):</span>
<pre>  <span class="term">\&lt;zero&gt; \&lt;lsq&gt; \&lt;one&gt;</span></pre></p>


<p><span class="command">and</span> <span class="name">Int_ZF_2_L16A(2):</span>
<pre>  <span class="term"><span class="free">abs</span>(\&lt;one&gt;) = \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L16B:</span>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; \&lt;two&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L16C:</span>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> ==&gt; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">a</span></span></pre>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> ==&gt; <span class="var">a</span> <span class="const">&ne;</span> \&lt;zero&gt;</span></pre>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> ==&gt; \&lt;two&gt; \&lt;lsq&gt; <span class="var">a</span> \&lt;ra&gt; \&lt;one&gt;</span></pre>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> ==&gt; \&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> \&lt;ra&gt; \&lt;one&gt;</span></pre>
<pre>  <span class="term">\&lt;one&gt; \&lt;lsq&gt; <span class="var">a</span> ==&gt; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">a</span> \&lt;ra&gt; \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L17:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="free">abs</span>(\&lt;rm&gt; <span class="var">m</span>) = <span class="free">abs</span>(<span class="var">m</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L18:</span>
<pre>  <span class="term"><span class="free">abs</span>(\&lt;zero&gt;) = \&lt;zero&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_triangle_ineq1:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">n</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">m</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_triangle_ineq2:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> |]
  ==&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">n</span>) \&lt;ra&gt; <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="var">m</span> \&lt;rs&gt; <span class="var">k</span> \&lt;lsq&gt; <span class="var">n</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span> \&lt;ra&gt; <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="var">n</span> \&lt;rs&gt; <span class="var">k</span> \&lt;lsq&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_triangle_ineq3:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt; |]
  ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;ra&gt; <span class="var">n</span> \&lt;ra&gt; <span class="var">k</span>) \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">n</span>) \&lt;ra&gt; <span class="free">abs</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L19:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; &not; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; &not; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; \&lt;rm&gt; <span class="var">n</span> \&lt;lsq&gt; \&lt;rm&gt; <span class="var">m</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; &not; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; <span class="var">m</span> <span class="const">&ne;</span> <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L19AA:</span>
<pre>  <span class="term">[| <span class="var">m</span> \&lt;lsq&gt; <span class="var">n</span>; <span class="var">m</span> <span class="const">&ne;</span> <span class="var">n</span> |] ==&gt; &not; <span class="var">n</span> \&lt;lsq&gt; <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L19A:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; &not; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; <span class="var">m</span> \&lt;lsq&gt; \&lt;zero&gt;</span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; &not; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; \&lt;zero&gt; \&lt;lsq&gt; \&lt;rm&gt; <span class="var">m</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; &not; \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span> |] ==&gt; <span class="var">m</span> <span class="const">&ne;</span> \&lt;zero&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L19B:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">Q</span>(\&lt;zero&gt;); &forall;<span class="bound">n</span>&isin;\&lt;int&gt;<sub>+</sub>. <span class="var">Q</span>(<span class="bound">n</span>); &forall;<span class="bound">n</span>&isin;\&lt;int&gt;<sub>+</sub>. <span class="var">Q</span>(\&lt;rm&gt; <span class="bound">n</span>) |] ==&gt; <span class="var">Q</span>(<span class="var">m</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L19C:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>)</span></pre>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; \&lt;rm&gt; <span class="var">m</span> \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L20:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt; |] ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) = <span class="free">abs</span>(<span class="var">n</span> \&lt;rs&gt; <span class="var">m</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L21:</span>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span>) \&lt;lsq&gt; <span class="var">k</span>; <span class="free">abs</span>(<span class="var">n</span>) \&lt;lsq&gt; <span class="var">l</span> |]
  ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;ra&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">l</span></span></pre>
<pre>  <span class="term">[| <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; \&lt;int&gt;; <span class="free">abs</span>(<span class="var">m</span>) \&lt;lsq&gt; <span class="var">k</span>; <span class="free">abs</span>(<span class="var">n</span>) \&lt;lsq&gt; <span class="var">l</span> |]
  ==&gt; <span class="free">abs</span>(<span class="var">m</span> \&lt;rs&gt; <span class="var">n</span>) \&lt;lsq&gt; <span class="var">k</span> \&lt;ra&gt; <span class="var">l</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">int_abs_nonneg:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; <span class="free">abs</span>(<span class="var">m</span>) &isin; \&lt;int&gt;<sup>+</sup></span></pre>
<pre>  <span class="term"><span class="var">m</span> &isin; \&lt;int&gt; ==&gt; \&lt;zero&gt; \&lt;lsq&gt; <span class="free">abs</span>(<span class="var">m</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_2_L23:</span>
<pre>  <span class="term">[| \&lt;zero&gt; \&lt;lsq&gt; <span class="var">m</span>; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> |] ==&gt; <span class="free">abs</span>(<span class="var">m</span>) \&lt;lsq&gt; <span class="var">k</span></span></pre></p>


<h2>Induction on integers.</h2>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L2:</span>
<pre>  <span class="term"><span class="var">i</span> \&lt;lsq&gt; <span class="var">m</span> ==&gt; &exist;<span class="bound">n</span>&isin;<span class="const">nat</span>. <span class="var">m</span> = <span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> <span class="bound">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L6:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; &forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">Q</span>(<span class="bound">m</span>) --&gt; <span class="var">Q</span>(<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>) |]
  ==&gt; &forall;<span class="bound">k</span>&isin;<span class="const">nat</span>. <span class="var">Q</span>(<span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> <span class="bound">k</span>) --&gt; <span class="var">Q</span>(<span class="var">i</span> <span class="const">$+</span> <span class="const">$#</span> succ(<span class="bound">k</span>))</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L7:</span>
<pre>  <span class="term">[| <span class="var">i</span> \&lt;lsq&gt; <span class="var">k</span>; <span class="var">Q</span>(<span class="var">i</span>); &forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">Q</span>(<span class="bound">m</span>) --&gt; <span class="var">Q</span>(<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>) |] ==&gt; <span class="var">Q</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L7A:</span>
<pre>  <span class="term">&forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">Q</span>(<span class="bound">m</span>) --&gt; <span class="var">Q</span>(<span class="bound">m</span> \&lt;ra&gt; \&lt;one&gt;)
  ==&gt; &forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">Q</span>(<span class="bound">m</span>) --&gt; <span class="var">Q</span>(<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>)</span></pre></p>

<p><span class="command">theorem</span> <span class="name">Induction_on_int:</span>
<pre>  <span class="term">[| <span class="var">i</span> \&lt;lsq&gt; <span class="var">k</span>; <span class="var">Q</span>(<span class="var">i</span>); &forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">Q</span>(<span class="bound">m</span>) --&gt; <span class="var">Q</span>(<span class="bound">m</span> \&lt;ra&gt; \&lt;one&gt;) |] ==&gt; <span class="var">Q</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L7B:</span>
<pre>  <span class="term">[| <span class="var">i</span> \&lt;lsq&gt; <span class="var">k</span>; <span class="var">P</span>(<span class="const">$-</span> <span class="var">i</span>); &forall;<span class="bound">m</span>. <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">P</span>(<span class="const">$-</span> <span class="bound">m</span>) --&gt; <span class="var">P</span>(<span class="const">$-</span> (<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>)) |]
  ==&gt; <span class="var">P</span>(<span class="const">$-</span> <span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L8:</span>
<pre>  <span class="term">[| <span class="var">k</span> \&lt;lsq&gt; <span class="var">i</span>; <span class="var">P</span>(<span class="var">i</span>); &forall;<span class="bound">m</span>. <span class="const">$-</span> <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">P</span>(<span class="const">$-</span> <span class="bound">m</span>) --&gt; <span class="var">P</span>(<span class="const">$-</span> (<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>)) |]
  ==&gt; <span class="var">P</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L9:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; &forall;<span class="bound">n</span>. <span class="bound">n</span> \&lt;lsq&gt; <span class="var">i</span> &and; <span class="var">P</span>(<span class="bound">n</span>) --&gt; <span class="var">P</span>(<span class="bound">n</span> <span class="const">$+</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span>) |]
  ==&gt; &forall;<span class="bound">m</span>. <span class="const">$-</span> <span class="var">i</span> \&lt;lsq&gt; <span class="bound">m</span> &and; <span class="var">P</span>(<span class="const">$-</span> <span class="bound">m</span>) --&gt; <span class="var">P</span>(<span class="const">$-</span> (<span class="bound">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>))</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L9A:</span>
<pre>  <span class="term">[| <span class="var">k</span> \&lt;lsq&gt; <span class="var">i</span>; <span class="var">P</span>(<span class="var">i</span>); &forall;<span class="bound">n</span>. <span class="bound">n</span> \&lt;lsq&gt; <span class="var">i</span> &and; <span class="var">P</span>(<span class="bound">n</span>) --&gt; <span class="var">P</span>(<span class="bound">n</span> <span class="const">$+</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span>) |] ==&gt; <span class="var">P</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_3_L10:</span>
<pre>  <span class="term">&forall;<span class="bound">n</span>. <span class="bound">n</span> \&lt;lsq&gt; <span class="var">i</span> &and; <span class="var">P</span>(<span class="bound">n</span>) --&gt; <span class="var">P</span>(<span class="bound">n</span> \&lt;rs&gt; \&lt;one&gt;)
  ==&gt; &forall;<span class="bound">n</span>. <span class="bound">n</span> \&lt;lsq&gt; <span class="var">i</span> &and; <span class="var">P</span>(<span class="bound">n</span>) --&gt; <span class="var">P</span>(<span class="bound">n</span> <span class="const">$+</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span>)</span></pre></p>

<p><span class="command">theorem</span> <span class="name">Back_induct_on_int:</span>
<pre>  <span class="term">[| <span class="var">k</span> \&lt;lsq&gt; <span class="var">i</span>; <span class="var">P</span>(<span class="var">i</span>); &forall;<span class="bound">n</span>. <span class="bound">n</span> \&lt;lsq&gt; <span class="var">i</span> &and; <span class="var">P</span>(<span class="bound">n</span>) --&gt; <span class="var">P</span>(<span class="bound">n</span> \&lt;rs&gt; \&lt;one&gt;) |] ==&gt; <span class="var">P</span>(<span class="var">k</span>)</span></pre></p>


<h2>Bounded vs. finite subsets of integers</h2>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L1:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">m</span> &isin; \&lt;int&gt;; <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> = <span class="var">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="var">n</span> |]
  ==&gt; <span class="var">m</span> = <span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> &or; <span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L1A:</span>
<pre>  <span class="term"><span class="var">m</span> &isin; <span class="const">int</span> ==&gt; <span class="var">m</span> <span class="const">$-</span> <span class="const">$#</span> <span class="const">1</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span> = <span class="var">m</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L1B:</span>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">L</span> ==&gt; <span class="var">m</span> = <span class="var">L</span> &or; <span class="var">m</span> \&lt;ra&gt; \&lt;one&gt; \&lt;lsq&gt; <span class="var">L</span></span></pre>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">L</span> ==&gt; <span class="var">m</span> = <span class="var">L</span> &or; <span class="var">m</span> \&lt;lsq&gt; <span class="var">L</span> \&lt;rs&gt; \&lt;one&gt;</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L2:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">j</span> &isin; <span class="var">m</span> .. (<span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>) |] ==&gt; <span class="var">j</span> &isin; <span class="var">m</span> .. <span class="var">k</span> &or; <span class="var">j</span> &isin; {<span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>}</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L3:</span>
<pre>  <span class="term"><span class="var">m</span> \&lt;lsq&gt; <span class="var">k</span> ==&gt; <span class="var">m</span> .. (<span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>) = <span class="var">m</span> .. <span class="var">k</span> &cup; {<span class="var">k</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>}</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L4:</span>
<pre>  <span class="term">[| <span class="var">i</span> \&lt;lsq&gt; <span class="var">m</span>; <span class="var">i</span> .. <span class="var">m</span> &isin; Fin(\&lt;int&gt;) |] ==&gt; <span class="var">i</span> .. (<span class="var">m</span> <span class="const">$+</span> <span class="const">$#</span> <span class="const">1</span>) &isin; Fin(\&lt;int&gt;)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L5:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt; |] ==&gt; <span class="var">i</span> .. <span class="var">k</span> &isin; Fin(\&lt;int&gt;)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L6:</span>
<pre>  <span class="term">IsBounded(<span class="var">A</span>, IntegerOrder) ==&gt; <span class="var">A</span> &isin; Fin(\&lt;int&gt;)</span></pre></p>

<p><span class="command">theorem</span> <span class="name">Int_bounded_iff_fin:</span>
<pre>  <span class="term">IsBounded(<span class="var">A</span>, IntegerOrder) &lt;-&gt; <span class="var">A</span> &isin; Fin(\&lt;int&gt;)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L8:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">f</span> &isin; \&lt;int&gt; <span class="const">-&gt;</span> \&lt;int&gt; |]
  ==&gt; <span class="var">f</span> `` (<span class="var">i</span> .. <span class="var">k</span>) &isin; Fin(\&lt;int&gt;)</span></pre>
<pre>  <span class="term">[| <span class="var">i</span> &isin; \&lt;int&gt;; <span class="var">k</span> &isin; \&lt;int&gt;; <span class="var">f</span> &isin; \&lt;int&gt; <span class="const">-&gt;</span> \&lt;int&gt; |]
  ==&gt; IsBounded(<span class="var">f</span> `` (<span class="var">i</span> .. <span class="var">k</span>), IntegerOrder)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Int_ZF_4_L9:</span>
<pre>  <span class="term">&forall;<span class="bound">m</span>&isin;\&lt;int&gt;. &exist;<span class="bound">k</span>&isin;<span class="var">A</span>. <span class="bound">m</span> \&lt;lsq&gt; <span class="bound">k</span> ==&gt; &not; IsBoundedAbove(<span class="var">A</span>, IntegerOrder)</span></pre>
<pre>  <span class="term">&forall;<span class="bound">m</span>&isin;\&lt;int&gt;. &exist;<span class="bound">k</span>&isin;<span class="var">A</span>. <span class="bound">m</span> \&lt;lsq&gt; <span class="bound">k</span> ==&gt; <span class="var">A</span> <span class="const">&notin;</span> Fin(\&lt;int&gt;)</span></pre></p>

</div>
</body>
</html>
