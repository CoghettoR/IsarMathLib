<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Semigroup_ZF (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Semigroup_ZF</h1>

<span class="command">theory</span> <span class="name">Semigroup_ZF</span><br/>
<span class="keyword">imports</span> <a href="Partitions_ZF.html"><span class="name">Partitions_ZF</span></a> <a href="Fold_ZF.html"><span class="name">Fold_ZF</span></a> <a href="Enumeration_ZF.html"><span class="name">Enumeration_ZF</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
    This file is a part of IsarMathLib - 
    a library of formalized mathematics for Isabelle/Isar.

    Copyright (C) 2007-2009  Slawomir Kolodynski

    This progr\rightarowam is free software; Redistribution and use in source and binary forms, 
    with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation and/or 
   other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products 
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Semigroups&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Semigroup_ZF</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Partitions_ZF</span><span> </span><span>Fold_ZF</span><span> </span><span>Enumeration_ZF</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;It seems that the minimal setup needed to talk about a product of a 
  sequence is a set with a binary operation. 
  Such object is called &quot;magma&quot;. However, interesting properties
  show up when the binary operation is associative and such alebraic structure
  is called a semigroup. 
  In this theory file we define and study sequences of partial 
  products of sequences of magma and semigroup elements.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Products of sequences of semigroup elements&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Semigroup is a a magma in which the binary operation is associative.
  In this section we mostly study the products of sequences of elements 
  of semigroup. The goal is to establish the fact that taking the product of 
  a sequence is distributive with respect to concatenation of sequences, 
  i.e for two sequences $a,b$ of the semigroup elements we have 
  $\prod (a\sqcup b) = (\prod a)\cdot (\prod b)$, where &quot;$a \sqcup b$&quot; 
  is concatenation of $a$ and $b$ ($a$&#8249;++&#8250;$b$ in Haskell notation).
  Less formally, we want to show that we can discard parantheses in 
  expressions of the form 
  $(a_0\cdot a_1\cdot .. \cdot a_n)\cdot (b_0\cdot .. \cdot b_k)$.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First we define a notion similar to &#8249;Fold&#8250;, except that
  that the initial element of the fold is given by the first element
  of sequence. By analogy with Haskell fold we call that &#8249;Fold1&#8250;
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Fold1(f,a) &#8801; Fold(f,a`(0),Tail(a))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The definition of the &#8249;semigr0&#8250; context below introduces notation
  for writing about finite sequences and semigroup products. 
  In the context we fix the carrier and
  denote it $G$. The binary operation on $G$ is called $f$. 
  All theorems proven in the context &#8249;semigr0&#8250; 
  will implicitly assume that $f$ is an associative operation on $G$.
  We will use multiplicative notation for the semigroup operation.
  The product of a sequence $a$ is denoted $\prod a$.
  We will write
  $a\hookleftarrow x$ for the result of appending an element $x$ to
  the finite sequence (list) $a$. This is a bit nonstandard, 
  but I don&#39;t have a better idea for the &quot;append&quot; notation. Finally,
  $a\sqcup b$ will denote the concatenation of the lists $a$ and $b$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>semigr0</span><span> </span><span class="delimiter">=</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span>f</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>assoc_assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is associative on} G&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>prod</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8901;&quot;</span></span></span><span> </span><span>72</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>prod_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8901; y &#8801; f`&#10216;x,y&#10217;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>seqprod</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8719; _&quot;</span></span></span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>seqprod_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8719; a &#8801; Fold1(f,a)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>append</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8617;&quot;</span></span></span><span> </span><span>72</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>append_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8617; x &#8801; Append(a,x)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>concat</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8852;&quot;</span></span></span><span> </span><span>69</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>concat_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8852; b &#8801; Concat(a,b)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The next lemma shows our assumption on the associativity
  of the semigroup operation in the notation defined in in the 
  &#8249;semigr0&#8250; context.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>semigr_assoc</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8712; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8901;y&#8901;z = x&#8901;(y&#8901;z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>assoc_assum</span><span> </span><span>IsAssociative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In the way we define associativity the assumption that
  $f$ is associative on $G$ also implies that it is a binary
  operation on $X$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>semigr_binop</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f : G&#215;G &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assoc_assum</span><span> </span><span>IsAssociative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Semigroup operation is closed.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>semigr_closed</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8712;G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b &#8712; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>semigr_binop</span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lemma &#8249;append_1elem&#8250; written in the notation used in 
  the &#8249;semigr0&#8250; context.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>append_1elem_nice</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a: n &#8594; X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : 1 &#8594; X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8852; b = a &#8617; b`(0)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>append_1elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lemma &#8249;concat_init_last_elem&#8250; rewritten
  in the notation used in the &#8249;semigr0&#8250; context.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>concat_init_last</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a: n &#8594; X&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(k) &#8594; X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a &#8852; Init(b)) &#8617; b`(k) = a &#8852; b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>concat_init_last_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The product of semigroup (actually, magma -- we don&#39;t
   need associativity for this) elements is in the semigroup.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_type</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8712; G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;succ(n) &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f : G&#215;G &#8594; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Tail(a) : n &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_binop</span><span> </span><span>tail_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a`(0) &#8712; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;G &#8800; 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_in_every_succ</span><span> </span><span>apply_funtype</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8712; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fold1_def</span><span> </span><span>fold_props</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;What is the product of one element list?&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_of_1elem</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a: 1 &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) = a`(0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f : G&#215;G &#8594; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_binop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Tail(a) : 0 &#8594; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail_props</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a`(0) &#8712; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;G &#8800; 0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) =  a`(0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fold_empty</span><span> </span><span>Fold1_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;What happens to the product of a list when we append an element 
  to the list?&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_append</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a&#8617;x) = (&#8719; a) &#8901; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Tail(a) : n &#8594; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a`(0) &#8712; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail_props</span><span> </span><span>empty_in_every_succ</span><span> </span><span>apply_funtype</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a&#8617;x) = Fold(f,a`(0),Tail(a)&#8617;x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>head_of_append</span><span> </span><span>tail_append_commute</span><span> </span><span>Fold1_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A3</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8719; a) &#8901; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_binop</span><span> </span><span>fold_append</span><span> </span><span>Fold1_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The main theorem of the section: taking the product of 
  a sequence is distributive with respect to concatenation of sequences.
  The proof is by induction on the length of the second list.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_conc_distr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b: succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b &#8712; succ(0) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(0) &#8594; G&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	</span><span class="string"><span class="delete"><span class="delete">&quot;succ(n) &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b : 1 &#8594; G&quot;</span></span></span><span> 
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8852; b = a &#8617; b`(0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>append_1elem_nice</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span>prod_append</span><span> </span><span>semigr_binop</span><span> </span><span>prod_of_1elem</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j &#8712; nat. 
    (&#8704;b &#8712; succ(j) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)) &#10230;
    (&#8704;b &#8712; succ(succ(j)) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>A5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;b &#8712; succ(j) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(succ(j)) &#8594; G&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Init(b)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A4</span><span> </span><span>A6</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b`(succ(j)) &#8712; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	  </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?c : succ(j) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = ?c&#8617;b`(succ(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span>init_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A4</span><span> </span><span>A6</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;succ(n) &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;succ(j) &#8712; nat&quot;</span></span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(succ(j)) &#8594; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>III</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a &#8852; ?c) &#8617; b`(succ(j)) = a &#8852; b&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>concat_init_last</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A4</span><span> </span><span>I</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; ?c&#8617;b`(succ(j))) = (&#8719; ?c) &#8901; b`(succ(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_append</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>II</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = (&#8719; a) &#8901; ((&#8719; ?c) &#8901; b`(succ(j)))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	</span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A4</span><span> </span><span>T</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8712; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; ?c) &#8712; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b`(succ(j)) &#8712; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) =  ((&#8719; a) &#8901; (&#8719; ?c)) &#8901; b`(succ(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A5</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = (&#8719; (a &#8852; ?c))&#8901;b`(succ(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	</span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A4</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	  </span><span>T1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(n) &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;succ(j) &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n) &#8594; G&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;?c : succ(j) &#8594; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Concat(a,?c): succ(n) #+ succ(j) &#8594; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>concat_props</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A4</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;succ(n #+ j) &#8712; nat&quot;</span></span></span><span>   
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8852; ?c : succ(succ(n #+j)) &#8594; G&quot;</span></span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;b`(succ(j)) &#8712; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; (a &#8852; ?c)&#8617;b`(succ(j))) = (&#8719; (a &#8852; ?c))&#8901;b`(succ(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_append</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>III</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; (a &#8852; ?c))&#8901;b`(succ(j)) =  &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;b &#8712; succ(succ(j)) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b))&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b &#8712; succ(k) &#8594; G. (&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ind_on_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) &#8901; (&#8719; b) = &#8719; (a &#8852; b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Products over sets of indices&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section we study the properties of 
  expressions of the form
  $\prod_{i\in \Lambda} a_i = a_{i_0}\cdot a_{i_1} \cdot .. \cdot a_{i-1}$,
  i.e. what we denote as &#8249;\&lt;pr&gt;(&#923;,a)&#8250;. $\Lambda$ here is
  a finite subset of some set $X$ and $a$ is a function defined
  on $X$ with values in the semigroup $G$.&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suppose $a: X \rightarrow G$ is an indexed family of elements
  of a semigroup $G$ and 
  $\Lambda = \{i_0, i_1, .. , i_{n-1}\} \subseteq \mathbb{N}$ is a finite 
  set of indices. We want to define 
  $\prod_{i\in \Lambda} a_i = a_{i_0}\cdot a_{i_1} \cdot .. \cdot a_{i-1}$.
  To do that we use the notion of &#8249;Enumeration&#8250; defined in the
  &#8249;Enumeration_ZF&#8250; theory file that takes a set of indices and 
  lists them in increasing order, thus converting it to list. Then we use 
  the &#8249;Fold1&#8250; to multiply the resulting list. Recall that in 
  Isabelle/ZF the capital letter &#39;&#39;O&#39;&#39; denotes the composition of two 
  functions (or relations).
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;SetFold(f,a,&#923;,r) = Fold1(f,a O Enumeration(&#923;,r))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;For 
  a finite subset $\Lambda$ of a linearly ordered set $X$
  we will write $\sigma (\Lambda )$ 
  to denote the enumeration of the elements of $\Lambda$, i.e. the only 
  order isomorphism $|\Lambda | \rightarrow \Lambda$, where 
  $|\Lambda | \in \mathbb{N}$ is the number of elements of $\Lambda $.
  We also define
  notation for taking a product over a set of indices of some sequence
  of semigroup elements. The product of semigroup
  elements over some set $\Lambda \subseteq X$ of indices
  of a sequence $a: X \rightarrow G$ (i.e. $\prod_{i\in \Lambda} a_i$) 
  is denoted &#8249;\&lt;pr&gt;(&#923;,a)&#8250;.
  In the &#8249;semigr1&#8250; context we assume that $a$ is a 
  function defined on some
  linearly ordered set $X$ with values in the semigroup $G$.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>semigr1</span><span> </span><span class="delimiter">=</span><span> </span><span>semigr0</span><span> </span><span class="delimiter">+</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span>r</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>linord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IsLinOrder(X,r)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_is_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : X &#8594; G&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>&#963;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>&#963;_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;(A) &#8801; Enumeration(A,r)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>setpr</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>setpr_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923;,b) &#8801; SetFold(f,b,&#923;,r)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We can use the &#8249;enums&#8250; locale in the &#8249;semigr0&#8250; 
  context.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>enums_valid_in_semigr1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;enums(X,r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linord</span><span> </span><span>enums_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition of product over a set expressed
  in notation of the &#8249;semigr0&#8250; locale.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>setproddef</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923;,a) = &#8719; (a O &#963;(&#923;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SetFold_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A composition of enumeration of a nonempty 
  finite subset of $\mathbb{N}$
  with a sequence of elements of $G$ is a nonempty list of elements of $G$.
  This implies that a product over set of a finite set of indices belongs
  to the (carrier of) semigroup.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>setprod_type</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923; &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923;&#8800;0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n &#8712; nat . |&#923;| = succ(n) &#8743; a O &#963;(&#923;) : succ(n) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923;,a) &#8712; G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|&#923;| = succ(n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_non_empty_succ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;(&#923;) : |&#923;| &#8594; &#923;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enums_valid_in_semigr1</span><span> </span><span>enums.enum_props</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a O &#963;(&#923;): |&#923;| &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>FinPow_def</span><span> </span><span>comp_fun_subset</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;|&#923;| = succ(n)&#8250;</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n &#8712; nat . |&#923;| = succ(n) &#8743; a O &#963;(&#923;) : succ(n) &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;|&#923;| = succ(n)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a O &#963;(&#923;): |&#923;| &#8594; G&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923;,a) &#8712; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_type</span><span> </span><span>setproddef</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The &#8249;enum_append&#8250; lemma from the 
  &#8249;Enemeration&#8250; theory specialized for natural
  numbers.&#8250;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>semigr1_enum_append</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923; &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X - &#923;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&#8712;&#923;. &#10216;k,n&#10217; &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;(&#923; &#8746; {n}) = &#963;(&#923;)&#8617; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span>FinPow_def</span><span> </span><span>enums_valid_in_semigr1</span><span> 
</span><span>    </span><span>enums.enum_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;What is product over a singleton?&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>gen_prod_singleton</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;({x},a) = a`(x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;({x}): 1 &#8594; X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;({x})`(0) = x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enums_valid_in_semigr1</span><span> </span><span>enums.enum_singleton</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;({x},a) = a`(x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>comp_fun</span><span> </span><span>setproddef</span><span> </span><span>prod_of_1elem</span><span> 
</span><span>      </span><span>comp_fun_apply</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A generalization of &#8249;prod_append&#8250; to the products
  over sets of indices.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>gen_prod_append</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923; &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923; &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X -  &#923;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&#8712;&#923;. &#10216;k,n&#10217; &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923; &#8746; {n}, a) = (\&lt;pr&gt;(&#923;,a)) &#8901; a`(n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923; &#8746; {n}, a) =  &#8719; (a O &#963;(&#923; &#8746; {n}))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>setproddef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A3</span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = &#8719; (a O (&#963;(&#923;)&#8617; n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr1_enum_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = &#8719; ((a O &#963;(&#923;))&#8617; a`(n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;|&#923;| &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#963;(&#923;) : |&#923;| &#8594; X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_fin_is_nat</span><span> </span><span>enums_valid_in_semigr1</span><span> </span><span>enums.enum_fun</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>list_compose_append</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8719; (a O &#963;(&#923;)))&#8901;a`(n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>setprod_type</span><span> </span><span>apply_funtype</span><span> </span><span>prod_append</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (\&lt;pr&gt;(&#923;,a)) &#8901; a`(n)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SetFold_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(&#923; &#8746; {n}, a) = (\&lt;pr&gt;(&#923;,a)) &#8901; a`(n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Very similar to &#8249;gen_prod_append&#8250;: a relation
  between a product over a set of indices and the product
  over the set with the maximum removed.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>gen_product_rem_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A - {n} &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&#8712;A. &#10216;k, n&#10217; &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(\&lt;pr&gt;(A - {n},a)) &#8901; a`(n) = \&lt;pr&gt;(A, a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?&#923;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A - {n}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?&#923; &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X -  ?&#923;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin_rem_point_fin</span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A3</span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?&#923; &#8746; {n}, a) = (\&lt;pr&gt;(?&#923;,a)) &#8901; a`(n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>gen_prod_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rem_add_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Commutative semigroups&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Commutative semigroups are those whose operation is 
  commutative, i.e. $a\cdot b = b\cdot a$. This implies that
  for any permutation $s : n \rightarrow n$ we have
  $\prod_{j=0}^n a_j = \prod_{j=0}^n a_{s (j)}$,
  or, closer to the notation we are using in the &#8249;semigr0&#8250;
  context, $\prod a = \prod (a \circ s )$. Maybe one day we 
  will be able to prove this, but for now the goal is to prove 
  something simpler: that if the semigroup operation is commutative
  taking the product of a sequence is distributive with respect
  to the operation: 
  $\prod_{j=0}^n (a_j\cdot b_j) = \left(\prod_{j=0}^n a_j)\right) \left(\prod_{j=0}^n b_j)\right)$.
  Many of the rearrangements (namely those that don&#39;t use the inverse)
  proven in the &#8249;AbelianGroup_ZF&#8250; theory hold in fact in semigroups.
  Some of them will be reproven in this section.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A rearrangement with 3 elements.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>rearr3elems</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c&#8712;G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;c = a&#8901;c&#8901;b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>semigr_assoc</span><span> </span><span>IsCommutative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A rearrangement of four elements.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>rearr4elems</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c&#8712;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;d&#8712;G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;(c&#8901;d) = a&#8901;c&#8901;(b&#8901;d)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;(c&#8901;d) = a&#8901;b&#8901;c&#8901;d&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_closed</span><span> </span><span>semigr_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;c&#8901;d =  a&#8901;c&#8901;(b&#8901;d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;c&#8901;d = c&#8901;(a&#8901;b)&#8901;d&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IsCommutative_def</span><span> </span><span>semigr_closed</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; =  c&#8901;a&#8901;b&#8901;d&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_closed</span><span> </span><span>semigr_assoc</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = a&#8901;c&#8901;b&#8901;d&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IsCommutative_def</span><span> </span><span>semigr_closed</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = a&#8901;c&#8901;(b&#8901;d)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigr_closed</span><span> </span><span>semigr_assoc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;c&#8901;d =  a&#8901;c&#8901;(b&#8901;d)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8901;b&#8901;(c&#8901;d) = a&#8901;c&#8901;(b&#8901;d)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We start with a version of &#8249;prod_append&#8250; that will shorten a bit
  the proof of the main theorem.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>shorter_seq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; succ(succ(k)) &#8594; G&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) = (&#8719; Init(a)) &#8901; a`(succ(k))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Init(a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;a`(succ(k)) &#8712; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?x : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span>init_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; ?x&#8617;a`(succ(k))) = (&#8719; ?x) &#8901; a`(succ(k))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_props</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A lemma useful in the induction step of the main theorem.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_distr_ind_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(succ(k)) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(succ(k)) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c : succ(succ(k)) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Init(a) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Init(b) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Init(c) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). Init(c)`(j) = Init(a)`(j) &#8901; Init(b)`(j)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span>A4</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;Init(a) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;Init(b) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;Init(c) : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(k) &#8712; nat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>T</span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). Init(a)`(j) = a`(j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_props</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>T</span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). Init(b)`(j) = b`(j)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_props</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>T</span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). Init(c)`(j) = c`(j)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_props</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A5</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). c`(j) = a`(j) &#8901; b`(j)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). Init(c)`(j) = Init(a)`(j) &#8901; Init(b)`(j)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;For commutative operations taking the product of a sequence 
  is distributive with respect to the operation.
  This version will probably not be used in applications,
  it is formulated in a way that is easier to prove by induction.
  For a more convenient formulation see &#8249;prod_comm_distrib&#8250;.
  The proof by induction on the length of the sequence.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_comm_distr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; a b c. 
  (a : succ(n)&#8594;G &#8743; b : succ(n)&#8594;G &#8743; c : succ(n)&#8594;G &#8743; 
  (&#8704;j&#8712;succ(n). c`(j) = a`(j) &#8901; b`(j))) &#10230;
  (&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; a b c. 
    (a : succ(0)&#8594;G &#8743; b : succ(0)&#8594;G &#8743; c : succ(0)&#8594;G &#8743; 
    (&#8704;j&#8712;succ(0). c`(j) = a`(j) &#8901; b`(j))) &#10230;
    (&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(0)&#8594;G &#8743; b : succ(0)&#8594;G &#8743; c : succ(0)&#8594;G &#8743; 
	(&#8704;j&#8712;succ(0). c`(j) = a`(j) &#8901; b`(j))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	</span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a : 1&#8594;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b : 1&#8594;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c : 1&#8594;G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c`(0) = a`(0) &#8901; b`(0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) = a`(0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; b) = b`(0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = c`(0)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_of_1elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>II</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fold1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &#8712; nat. 
    (&#8704; a b c. 
    (a : succ(k)&#8594;G &#8743; b : succ(k)&#8594;G &#8743; c : succ(k)&#8594;G &#8743; 
    (&#8704;j&#8712;succ(k). c`(j) = a`(j) &#8901; b`(j))) &#10230;
    (&#8719; c) = (&#8719; a) &#8901; (&#8719; b)) &#10230;
    (&#8704; a b c. 
    (a : succ(succ(k))&#8594;G &#8743; b : succ(succ(k))&#8594;G &#8743; c : succ(succ(k))&#8594;G &#8743; 
    (&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j))) &#10230;
    (&#8719; c) = (&#8719; a) &#8901; (&#8719; b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;a b c.
      a &#8712; succ(k) &#8594; G &#8743;
      b &#8712; succ(k) &#8594; G &#8743; c &#8712; succ(k) &#8594; G &#8743; 
      (&#8704;j&#8712;succ(k). c`(j) = a`(j) &#8901; b`(j)) &#10230;
      (&#8719; c) = (&#8719; a) &#8901; (&#8719; b)) &#10230;
      (&#8704;a b c.
      a &#8712; succ(succ(k)) &#8594; G &#8743;
      b &#8712; succ(succ(k)) &#8594; G &#8743;
      c &#8712; succ(succ(k)) &#8594; G &#8743; 
      (&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j)) &#10230;
      (&#8719; c) = (&#8719; a) &#8901; (&#8719; b))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;a b c.
	a &#8712; succ(k) &#8594; G &#8743;
	b &#8712; succ(k) &#8594; G &#8743; c &#8712; succ(k) &#8594; G &#8743; 
	(&#8704;j&#8712;succ(k). c`(j) = a`(j) &#8901; b`(j)) &#10230;
	(&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;a b c.
	a &#8712; succ(succ(k)) &#8594; G &#8743;
	b &#8712; succ(succ(k)) &#8594; G &#8743;
	c &#8712; succ(succ(k)) &#8594; G &#8743; 
	(&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j)) &#10230;
	(&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> 
</span><span>	  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; succ(succ(k)) &#8594; G &#8743;
	    b &#8712; succ(succ(k)) &#8594; G &#8743;
	    c &#8712; succ(succ(k)) &#8594; G &#8743; 
	    (&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(succ(k)) &#8594; G&quot;</span></span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(succ(k)) &#8594; G&quot;</span></span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;c : succ(succ(k)) &#8594; G&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(succ(k)). c`(j) = a`(j) &#8901; b`(j)&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>	  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Init(a)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Init(b)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?z</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Init(c)&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>III</span><span class="delimiter">:</span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; a) = (&#8719; ?x) &#8901; a`(succ(k))&quot;</span></span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; b) = (&#8719; ?y) &#8901; b`(succ(k))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	    </span><span>IV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = (&#8719; ?z) &#8901; c`(succ(k))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>shorter_seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span>I</span><span> </span><span>II</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;?x : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;?y : succ(k) &#8594; G&quot;</span></span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;?z : succ(k) &#8594; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(k). ?z`(j) = ?x`(j) &#8901; ?y`(j)&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_distr_ind_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A3</span><span> </span><span>II</span><span> </span><span>IV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = (&#8719; ?x)&#8901;(&#8719; ?y)&#8901;(a`(succ(k)) &#8901; b`(succ(k)))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span>I</span><span> </span><span>III</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; ?x)&#8901;(&#8719; ?y)&#8901;(a`(succ(k)) &#8901; b`(succ(k)))=
	    (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span> 
</span><span>	    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_props</span><span> </span><span>prod_type</span><span> </span><span>apply_funtype</span><span> 
</span><span>	      </span><span>rearr4elems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	</span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ind_on_nat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A reformulation of &#8249;prod_comm_distr&#8250; that is more
  convenient in applications.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr0</span><span class="delimiter">)</span><span> </span><span>prod_comm_distrib</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a : succ(n)&#8594;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b : succ(n)&#8594;G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c : succ(n)&#8594;G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&#8712;succ(n). c`(j) = a`(j) &#8901; b`(j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; c) = (&#8719; a) &#8901; (&#8719; b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prod_comm_distr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A product of two products over disjoint sets of indices is the 
  product over the union.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_bisect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#923; &#8712; FinPow(X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;P &#8712;  Bisections(&#923;). \&lt;pr&gt;(&#923;,a) = (\&lt;pr&gt;(fst(P),a))&#8901;(\&lt;pr&gt;(snd(P),a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IsLinOrder(X,r)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;P &#8712;  Bisections(0). \&lt;pr&gt;(0,a) = (\&lt;pr&gt;(fst(P),a))&#8901;(\&lt;pr&gt;(snd(P),a))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; A &#8712; FinPow(X). 
    ( &#8704; n &#8712; X - A. 
    (&#8704;P &#8712;  Bisections(A). \&lt;pr&gt;(A,a) = (\&lt;pr&gt;(fst(P),a))&#8901;(\&lt;pr&gt;(snd(P),a))) 
    &#8743; (&#8704;k&#8712;A. &#10216;k,n&#10217; &#8712; r ) &#10230; 
    (&#8704;Q &#8712;  Bisections(A &#8746; {n}). 
    \&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(fst(Q),a))&#8901;(\&lt;pr&gt;(snd(Q),a))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; FinPow(X)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X - A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( &#8704;P &#8712; Bisections(A). 
	\&lt;pr&gt;(A,a) = (\&lt;pr&gt;(fst(P),a))&#8901;(\&lt;pr&gt;(snd(P),a))) 
	&#8743; (&#8704;k&#8712;A. &#10216;k,n&#10217; &#8712; r )  &#10230; 
	(&#8704;Q &#8712;  Bisections(A &#8746; {n}). 
	\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(fst(Q),a))&#8901;(\&lt;pr&gt;(snd(Q),a)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;P &#8712; Bisections(A). \&lt;pr&gt;(A,a) = (\&lt;pr&gt;(fst(P),a))&#8901;(\&lt;pr&gt;(snd(P),a))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&#8712;A. &#10216;k,n&#10217; &#8712; r&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Q &#8712;  Bisections(A &#8746; {n}). 
	    \&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(fst(Q),a))&#8901;(\&lt;pr&gt;(snd(Q),a))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Q</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q &#8712;  Bisections(A &#8746; {n})&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst(Q)&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd(Q)&quot;</span></span></span><span>	      
</span><span>	      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8746; {n} &#8712; FinPow(X)&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_in_finpow</span><span> </span><span>union_finpow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712;  Bisections(A &#8746; {n})&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>		</span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> &#8800; 0&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisect_fin</span><span> </span><span>bisec_is_pair</span><span> </span><span>Bisections_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a) &#8712; G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a) &#8712; G&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>setprod_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712; Bisections(A &#8746; {n})&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X-A&#8250;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;refl(X,r)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> &#8838; A &#8746; {n}&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> &#8838; A &#8746; {n}&quot;</span></span></span><span> 
</span><span>		</span><span class="string"><span class="delete"><span class="delete">&quot;A &#8838; X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linord</span><span> </span><span>IsLinOrder_def</span><span> </span><span>total_is_refl</span><span> </span><span>Bisections_def</span><span>
</span><span>		</span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;refl(X,r)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>0</sub> &#8838; A &#8746; {n}&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8838; X&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X&#8250;</span></span></span><span> </span><span>II</span><span> 
</span><span>	      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>III</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &#8712; ?Q<span class="hidden">&#8681;</span><sub>0</sub>. &#10216;k, n&#10217; &#8712; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl_add_point</span><span class="delimiter">)</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;refl(X,r)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>1</sub> &#8838; A &#8746; {n}&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8838; X&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X&#8250;</span></span></span><span> </span><span>II</span><span> 
</span><span>	      </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>IV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &#8712; ?Q<span class="hidden">&#8681;</span><sub>1</sub>. &#10216;k, n&#10217; &#8712; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl_add_point</span><span class="delimiter">)</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712;  Bisections(A &#8746; {n})&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>		</span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> = {n} &#8744; ?Q<span class="hidden">&#8681;</span><sub>1</sub> = {n} &#8744; &#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n},?Q<span class="hidden">&#8681;</span><sub>1</sub>-{n}&#10217; &#8712;  Bisections(A)&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_is_pair</span><span> </span><span>bisec_add_point</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> = {n}&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8713; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712;  Bisections(A &#8746; {n})&#8250;</span></span></span><span> 
</span><span>		</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>,?Q<span class="hidden">&#8681;</span><sub>1</sub> &#10217; &#8712;  Bisections(A &#8746; {n})&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_is_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>1</sub> = {n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>, {n}&#10217; &#8712;  Bisections(A &#8746; {n})&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> = A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> 
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_point_bisec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span>II</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>1</sub> = {n}&#8250;</span></span></span><span> 
</span><span>		</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a)&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>gen_prod_append</span><span> </span><span>gen_prod_singleton</span><span> 
</span><span>		  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> = {n}&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n} &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n} &#8800; 0&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_in_finpow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8713; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712; Bisections(A &#8746; {n})&#8250;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>, ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#10217; &#8712;  Bisections(A &#8746; {n})&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_is_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>0</sub> = {n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;{n}, ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#10217; &#8712;  Bisections(A &#8746; {n})&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> = A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>point_set_bisec</span><span>
</span><span>		  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span>II</span><span>
</span><span>		  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{n} &#8712; FinPow(X)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{n} &#8800; 0&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>0</sub> = {n}&#8250;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;(\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a))&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>gen_prod_append</span><span> </span><span>gen_prod_singleton</span><span> 
</span><span>		    </span><span>setprod_type</span><span> </span><span>IsCommutative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n},?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n}&#10217; &#8712;  Bisections(A)&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>		  </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n} &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n} &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>		  </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n} &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n} &#8800; 0&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FinPow_def</span><span> </span><span>Bisections_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>		  </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n},a) &#8712; G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n},a) &#8712; G&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>		  </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a`(n) &#8712; G&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>setprod_type</span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q &#8712; Bisections(A &#8746; {n})&#8250;</span></span></span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>		  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>, ?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n}&#10217; &#8712; Bisections(A) &#8743; n &#8712; ?Q<span class="hidden">&#8681;</span><sub>1</sub>) &#8744; 
		  (&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n}, ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#10217; &#8712; Bisections(A) &#8743; n &#8712; ?Q<span class="hidden">&#8681;</span><sub>0</sub>) &quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_is_pair</span><span> </span><span>bisec_add_point_case3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>		</span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>, ?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n}&#10217; &#8712; Bisections(A)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; ?Q<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span>I</span><span> </span><span>II</span><span> </span><span>T</span><span> </span><span>IV</span><span>
</span><span>		    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub>, ?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n}&#10217; &#8712; Bisections(A)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a) &#8712; G&#8250;</span></span></span><span> 
</span><span>		    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n},a) &#8712; G&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>1</sub> &#8712; FinPow(X)&#8250;</span></span></span><span> 
</span><span>		    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>1</sub> - {n} &#8800; 0&#8250;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;(\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a))&quot;</span></span></span><span>
</span><span>		    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen_prod_append</span><span> </span><span>semigr_assoc</span><span> </span><span>gen_product_rem_point</span><span> 
</span><span>		    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n}, ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#10217; &#8712; Bisections(A)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; ?Q<span class="hidden">&#8681;</span><sub>0</sub>&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bisec_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>		  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; X - A&#8250;</span></span></span><span> </span><span>I</span><span> </span><span>II</span><span> </span><span>III</span><span> </span><span>T</span><span> 
</span><span>		    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10216;?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n}, ?Q<span class="hidden">&#8681;</span><sub>1</sub>&#10217;&#8712;Bisections(A)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub> - {n},a)&#8712;G&#8250;</span></span></span><span> 
</span><span>		    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a) &#8712; G&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>0</sub> &#8712; FinPow(X)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8712; ?Q<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?Q<span class="hidden">&#8681;</span><sub>0</sub>-{n}&#8800;0&#8250;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;(\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a))&quot;</span></span></span><span>
</span><span>		    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen_prod_append</span><span> </span><span>rearr3elems</span><span> </span><span>gen_product_rem_point</span><span> 
</span><span>		      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>		  </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;(\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a))&quot;</span></span></span><span>
</span><span>		  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A &#8746; {n},a) = (\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>0</sub>,a))&#8901;(\&lt;pr&gt;(?Q<span class="hidden">&#8681;</span><sub>1</sub>,a))&quot;</span></span></span><span>
</span><span>		</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>	
</span><span>	    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fin_ind_add_max</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A better looking reformulation of &#8249;prod_bisect&#8250;.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_disjoint</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8745; B = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(A&#8746;B,a) = (\&lt;pr&gt;(A,a))&#8901;(\&lt;pr&gt;(B,a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;A,B&#10217; &#8712; Bisections(A&#8746;B)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_bisec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>union_finpow</span><span> </span><span>prod_bisect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A generalization of &#8249;prod_disjoint&#8250;.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_list_of_lists</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M &#8712; succ(n) &#8594; FinPow(X). 
  M {is partition} &#10230; 
  (&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; succ(n)}) = 
  (\&lt;pr&gt;(&#8899;i &#8712; succ(n). M`(i),a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M &#8712; succ(0) &#8594; FinPow(X). 
    M {is partition} &#10230; 
    (&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; succ(0)}) = (\&lt;pr&gt;(&#8899;i &#8712; succ(0). M`(i),a))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>func1_1_L1</span><span> </span><span>Partition_def</span><span> </span><span>apply_funtype</span><span> </span><span>setprod_type</span><span>
</span><span>      </span><span>list_len1_singleton</span><span> </span><span>prod_of_1elem</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &#8712; nat. 
    (&#8704;M &#8712; succ(k) &#8594; FinPow(X). 
    M {is partition} &#10230; 
    (&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; succ(k)}) = 
    (\&lt;pr&gt;(&#8899;i &#8712; succ(k). M`(i),a))) &#10230;
    (&#8704;M &#8712; succ(succ(k)) &#8594; FinPow(X). 
    M {is partition} &#10230; 
    (&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; succ(succ(k))}) = 
    (\&lt;pr&gt;(&#8899;i &#8712; succ(succ(k)). M`(i),a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;M &#8712; succ(k) &#8594; FinPow(X). 
	M {is partition} &#10230; 
	(&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; succ(k)}) = 
	(\&lt;pr&gt;(&#8899;i &#8712; succ(k). M`(i),a))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;N &#8712; succ(succ(k)) &#8594; FinPow(X). 
	N {is partition} &#10230; 
	(&#8719; {&#10216;i,\&lt;pr&gt;(N`(i),a)&#10217;. i &#8712; succ(succ(k))}) = 
	(\&lt;pr&gt;(&#8899;i &#8712; succ(succ(k)). N`(i),a)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N : succ(succ(k)) &#8594; FinPow(X)&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N {is partition}&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; succ(succ(k)). N`(i) &#8800; 0&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span>Partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;i,\&lt;pr&gt;(N`(i),a)&#10217;. i &#8712; succ(succ(k))}&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;i,\&lt;pr&gt;(N`(i),a)&#10217;. i &#8712; succ(k)}&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; succ(succ(k)). \&lt;pr&gt;(N`(i),a) &#8712; G&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>	    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &#8712; succ(succ(k))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A4</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(i) &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(i) &#8800; 0&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(N`(i),a) &#8712; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>setprod_type</span><span>
</span><span>	      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; succ(k).  \&lt;pr&gt;(N`(i),a) &#8712; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?c : succ(k) &#8594; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ZF_fun_from_total</span><span class="delimiter">)</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?b = {&#10216;i,\&lt;pr&gt;(N`(i),a)&#10217;. i &#8712; succ(succ(k))}&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>II</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?b = Append(?c,\&lt;pr&gt;(N`(succ(k)),a))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_list_append</span><span class="delimiter">)</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">with</span></span><span>  </span><span>II</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?c : succ(k) &#8594; G&#8250;</span></span></span><span> 
</span><span>	  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; ?b) = (&#8719; ?c)&#8901;(\&lt;pr&gt;(N`(succ(k)),a))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>	    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; =  (\&lt;pr&gt;(&#8899;i &#8712; succ(k). N`(i),a))&#8901;(\&lt;pr&gt;(N`(succ(k)),a))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;restrict(N,succ(k))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(k) &#8838; succ(succ(k))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N : succ(succ(k)) &#8594; FinPow(X)&#8250;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M : succ(k) &#8594; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	      </span><span>III</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; succ(k). ?M`(i) = N`(i)&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_type2</span><span> </span><span>restrict</span><span> </span><span>apply_funtype</span><span> 
</span><span>	      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A5</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M : succ(k) &#8594; FinPow(X)&#8250;</span></span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M {is partition}&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func1_1_L1</span><span> </span><span>Partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A3</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M : succ(k) &#8594; FinPow(X)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>	      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; {&#10216;i,\&lt;pr&gt;(?M`(i),a)&#10217;. i &#8712; succ(k)}) = 
	      (\&lt;pr&gt;(&#8899;i &#8712; succ(k). ?M`(i),a))&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>III</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (\&lt;pr&gt;(&#8899;i &#8712; succ(succ(k)). N`(i),a))&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;i &#8712; succ(k). N`(i)&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(succ(k))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8712; nat&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ(k) &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; succ(k). N`(i) &#8712; FinPow(X)&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>union_fin_list_fin</span><span class="delimiter">)</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A4</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>	      </span><span class="string"><span class="delete"><span class="delete">&quot;N`(succ(k)) &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N`(succ(k)) &#8800; 0&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;succ(k) &#8712; nat&#8250;</span></span></span><span> </span><span>A4</span><span> </span><span>A5</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8745; ?B = 0&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_partition</span><span class="delimiter">)</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A1</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?A&#8746;?B,a) = (\&lt;pr&gt;(?A,a))&#8901;(\&lt;pr&gt;(?B,a))&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_disjoint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8746; ?B = (&#8899;i &#8712; succ(succ(k)). N`(i))&quot;</span></span></span><span>
</span><span>	      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; {&#10216;i,\&lt;pr&gt;(N`(i),a)&#10217;. i &#8712; succ(succ(k))}) = 
	    (\&lt;pr&gt;(&#8899;i &#8712; succ(succ(k)). N`(i),a))&quot;</span></span></span><span>
</span><span>	    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ind_on_nat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A more convenient reformulation of &#8249;prod_list_of_lists&#8250;.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_list_of_sets</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8712; nat&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M : n &#8594; FinPow(X)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;M {is partition}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; {&#10216;i,\&lt;pr&gt;(M`(i),a)&#10217;. i &#8712; n}) = (\&lt;pr&gt;(&#8899;i &#8712; n. M`(i),a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n = succ(k)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nat_ZF_1_L3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A1</span><span> </span><span>A3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_list_of_lists</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The definition of the product 
  &#8249;\&lt;pr&gt;(A,a) &#8801; SetFold(f,a,A,r)&#8250; of a some (finite) set of 
  semigroup elements requires that $r$ is a linear order on the set 
  of indices $A$. This is necessary so that we know in which order
  we are multiplying the elements. The product over $A$ is defined 
  so that we have $\prod_A a = \prod a \circ \sigma(A)$ where
  $\sigma : |A| \rightarrow A$ is the enumeration of $A$ (the only
  order isomorphism between the number of elements in $A$ and $A$), see
  lemma &#8249;setproddef&#8250;.
  However, if the operation is commutative, the order is irrelevant. 
  The next theorem formalizes that fact stating that we can replace
  the enumeration $\sigma (A)$ by any bijection between $|A|$ and $A$.
  In a way this is a generalization of &#8249;setproddef&#8250;. 
  The proof is based on application of &#8249;prod_list_of_sets&#8250;
  to the finite collection of singletons that comprise $A$.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_order_irr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bij(|A|,A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; (a O b)) = \&lt;pr&gt;(A,a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?n</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A|&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;k, {b`(k)}&#10217;. k &#8712; ?n}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; (a O b)) = (&#8719; {&#10216;i,\&lt;pr&gt;(?M`(i),a)&#10217;. i &#8712; ?n})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &#8712; ?n. \&lt;pr&gt;(?M`(i),a) = (a O b)`(i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &#8712; ?n&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712; ?n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b`(i) &#8712; X&quot;</span></span></span><span> 
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>apply_funtype</span><span> </span><span>FinPow_def</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;({b`(i)},a) = a`(b`(i))&quot;</span></span></span><span> 
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen_prod_singleton</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A3</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712; ?n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;({b`(i)},a) = (a O b)`(i)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>comp_fun_apply</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712; ?n&#8250;</span></span></span><span> </span><span>A3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;\&lt;pr&gt;(?M`(i),a) = (a O b)`(i)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_partition</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;i,\&lt;pr&gt;(?M`(i),a)&#10217;. i &#8712; ?n} = {&#10216;i,(a O b)`(i)&#10217;. i &#8712; ?n}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;i,(a O b)`(i)&#10217;. i &#8712; ?n} = a O b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : ?n &#8594; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8838; X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FinPow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b : ?n &#8594; X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>func1_1_L1B</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a O b: ?n &#8594; G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_is_fun</span><span> </span><span>comp_fun</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{&#10216;i,(a O b)`(i)&#10217;. i &#8712; ?n} = a O b&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_set_of_pairs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (\&lt;pr&gt;(&#8899;i &#8712; ?n. ?M`(i),a))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>A1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?n &#8712; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?n &#8800; 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_fin_is_nat</span><span> </span><span>card_non_empty_non_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M : ?n &#8594; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M {is partition}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &#8712; ?n. {b`(k)} &#8712;  FinPow(X)&quot;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>apply_funtype</span><span> </span><span>FinPow_def</span><span>
</span><span>	  </span><span>singleton_in_finpow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M : ?n &#8594; FinPow(X)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ZF_fun_from_total</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M {is partition}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_partition</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; {&#10216;i,\&lt;pr&gt;(?M`(i),a)&#10217;. i &#8712; ?n}) = (\&lt;pr&gt;(&#8899;i &#8712; ?n. ?M`(i),a))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_list_of_sets</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(\&lt;pr&gt;(&#8899;i &#8712; ?n. ?M`(i),a)) = \&lt;pr&gt;(A,a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_def</span><span> </span><span>inj_partition</span><span> </span><span>surj_singleton_image</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Another way of expressing the fact that the product dos not depend
  on the order.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigr1</span><span class="delimiter">)</span><span> </span><span>prod_bij_same</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f {is commutative on} G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; FinPow(X)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8800; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bij(|A|,A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712; bij(|A|,A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8719; (a O b)) = (&#8719; (a O c))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prod_order_irr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
