<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Theory Nat_ZF (Isabelle2007: November 2007)</title>
<link rel="stylesheet" type="text/css" href="isabelle.css">
</head>

<body>
<div class="head"><h1>Theory Nat_ZF</h1>


<p><a href="index.html">Up</a> to index of Isabelle/ZF/IsarMathLib</p>
<span class="command">theory</span> <span class="name">Nat_ZF</span><br>
<span class="keyword">imports</span> <a href="../Arith.html"><span class="name">Arith</span></a><br>
<span class="keyword">begin</span><br>

</div>
<hr>
<div class="source">
<pre>(* 
    This file is a part of IsarMathLib - 
    a library of formalized mathematics for Isabelle/Isar.

    Copyright (C) 2005 - 2008  Slawomir Kolodynski

    This program is free software Redistribution and use in source and binary forms, 
    with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation and/or 
   other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products 
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE, DATA, OR PROFITS 
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*)

header{*\isaheader{Nat\_ZF.thy}*}

theory Nat_ZF imports Arith

begin

text{*The  ZF set theory constructs natural numbers from the empty set
  and the notion of a one-element set. Namely, zero of natural numbers
  is defined as the empty set. For each natural number $n$ the next natural
  number is defined as $n\cup \{n\}$. With this definition for every
  non-zero natural number we get the identity $n = \{0,1,2,..,n-1\}$.
  It is good to remember that when we see an expression like
  $f: n \rightarrow X$. Also, with this definition 
  the relation "less or equal than" becomes "$\subseteq$" and 
  the relation "less than" becomes "$\in$".
  *}

section{*Induction*}

text{*The induction lemmas in the standard Isabelle's Nat.thy file like 
  for example @{text "nat_induct"} require the induction step to 
  be a higher order 
  statement (the one that uses the $\Longrightarrow$ sign). I found it 
  difficult to apply from Isar, which is perhaps more of an indication of 
  my Isar skills than anything else. Anyway, here we provide a first order
  version that is easier to reference in Isar declarative style proofs.*}

(*text{*The induction step for the first order induction.*}

lemma Nat_ZF_1_L1: assumes "x&isin;nat"  "P(x)" 
  and "&forall;k&isin;nat. P(k)--&gt;P(succ(k))"
  shows "P(succ(x))" using assms by simp

text{*The actual first order induction on natural numbers.*}

lemma Nat_ZF_1_L2: 
  assumes A1: "n&isin;nat" and A2: "P(0)" and A3: "&forall;k&isin;nat. P(k)--&gt;P(succ(k))"
  shows "P(n)"
proof -
  from A1 A2 have "n&isin;nat" "P(0)" by auto
  then show "P(n)" using Nat_ZF_1_L1 by (rule nat_induct)
qed*)

text{*The next theorem is a version of induction on natural numbers
  that I was thought in school.*}

theorem ind_on_nat: 
  assumes A1: "n&isin;nat" and A2: "P(0)" and A3: "&forall;k&isin;nat. P(k)--&gt;P(succ(k))"
  shows "P(n)"
proof -
  note A1 A2
  moreover
  { fix x
    assume "x&isin;nat"  "P(x)" and "&forall;k&isin;nat. P(k)--&gt;P(succ(k))"
    hence "P(succ(x))" by simp }
  ultimately show  "P(n)" by (rule nat_induct)
qed

text{*A nonzero natural number has a predecessor.*}

lemma Nat_ZF_1_L3: assumes A1: "n &isin; nat" and A2: "n&ne;0"
  shows "&exist;k&isin;nat. n = succ(k)"
proof -
  from A1 have "n &isin; {0} &cup; {succ(k). k&isin;nat}"
    using nat_unfold by simp
  with A2 show ?thesis by simp
qed

text{*What is @{text "succ"}, anyway?*}

lemma succ_explained: shows "succ(n) = n &cup; {n}"
  using succ_iff by auto

text{*Empty set is an element of every natural number which is not zero.*}

lemma empty_in_every_succ: assumes A1: "n &isin; nat"
  shows "0 &isin; succ(n)"
proof -
  note A1
  moreover have "0 &isin; succ(0)" by simp
  moreover
  { fix k assume "k &isin; nat" and A2: "0 &isin; succ(k)"
    then have "succ(k) &sube; succ(succ(k))" by auto
    with A2 have "0 &isin; succ(succ(k))" by auto
  } then have "&forall;k &isin; nat. 0 &isin; succ(k) --&gt; 0 &isin; succ(succ(k))"
    by simp
  ultimately show "0 &isin; succ(n)" by (rule ind_on_nat)
qed  

text{*If one natural number is less than another then their successors
  are in the same relation.*}

lemma succ_ineq: assumes A1: "n &isin; nat"
  shows "&forall;i &isin; n. succ(i) &isin; succ(n)"
proof -
  note A1
  moreover have "&forall;k &isin; 0. succ(k) &isin; succ(0)" by simp 
  moreover
  { fix k assume A2: "&forall;i&isin;k. succ(i) &isin; succ(k)"
    { fix i assume "i &isin; succ(k)"
      then have "i &isin; k &or; i = k" by auto
      moreover
      { assume "i&isin;k"
        with A2 have "succ(i) &isin; succ(k)" by simp
        hence "succ(i) &isin; succ(succ(k))" by auto }
      moreover
      { assume "i = k"
        then have "succ(i) &isin; succ(succ(k))" by auto }
      ultimately have "succ(i) &isin; succ(succ(k))" by auto
    } then have "&forall;i &isin; succ(k). succ(i) &isin; succ(succ(k))"
      by simp
  } then have "&forall;k &isin; nat. 
      ( (&forall;i&isin;k. succ(i) &isin; succ(k)) --&gt; (&forall;i &isin; succ(k). succ(i) &isin; succ(succ(k))) )"
    by simp
  ultimately show "&forall;i &isin; n. succ(i) &isin; succ(n)" by (rule ind_on_nat)
qed

text{*For natural numbers if $k\subseteq n$ the similar holds for 
  their successors. *}

lemma succ_subset: assumes A1: "k &isin; nat"  "n &isin; nat" and A2: "k&sube;n" 
  shows "succ(k) &sube; succ(n)"
proof -
  from A1 have T: "Ord(k)" and "Ord(n)"
    using nat_into_Ord by auto
  with A2 have "succ(k) &le; succ(n)"
    using subset_imp_le by simp
  then show "succ(k) &sube; succ(n)" using le_imp_subset
    by simp
qed

text{*For any two natural numbers one of them is contained in the other.*}

lemma nat_incl_total: assumes A1: "i &isin; nat"  "j &isin; nat"
  shows "i &sube; j &or; j &sube; i"
proof -
  from A1 have T: "Ord(i)"   "Ord(j)" 
    using nat_into_Ord by auto
  then have "i&isin;j &or; i=j &or; j&isin;i" using Ord_linear
    by simp
  moreover
  { assume "i&isin;j"
    with T have "i&sube;j &or; j&sube;i"
      using lt_def leI le_imp_subset by simp }
  moreover
  { assume "i=j"
    then have "i&sube;j &or; j&sube;i" by simp }
  moreover
  { assume "j&isin;i"
    with T have "i&sube;j &or; j&sube;i" 
      using lt_def leI  le_imp_subset by simp }
  ultimately show "i &sube; j &or; j &sube; i" by auto
qed

text{*The set of natural numbers is the union of all successors of natural
  numbers.*}

lemma nat_union_succ: shows "nat = (\&lt;Union&gt;n &isin; nat. succ(n))"
proof
  show "nat &sube; (\&lt;Union&gt;n &isin; nat. succ(n))" by auto
next
  { fix k assume A2: "k &isin; (\&lt;Union&gt;n &isin; nat. succ(n))"
    then obtain n where T: "n &isin; nat" and I: "k &isin; succ(n)"
      by auto
    with I have "k &le; n" using nat_into_Ord lt_def
      by simp
    with T have "k &isin; nat" using le_in_nat by simp
  } then show  "(\&lt;Union&gt;n &isin; nat. succ(n)) &sube; nat" by auto
qed

text{*Successors of natural numbers are subsets of the set of natural numbers.*}

lemma succnat_subset_nat: assumes A1: "n &isin; nat" shows "succ(n) &sube; nat"
proof -
  from A1 have "succ(n) &sube; (\&lt;Union&gt;n &isin; nat. succ(n))" by auto
  then show "succ(n) &sube; nat" using nat_union_succ by simp
qed

text{*Element of a natural number is a natural number.*}

lemma elem_nat_is_nat: assumes A1: "n &isin; nat"  and A2: "k&isin;n"
  shows "k &lt; n" and "k &isin; nat"  
proof -
  from A1 A2 show "k &lt; n" using nat_into_Ord lt_def by simp
  with A1 show "k &isin; nat" using lt_nat_in_nat by simp
qed

text{*Adding a natural numbers does not decrease what we add to.*}

lemma add_nat_le: assumes A1: "n &isin; nat"  and A2: "k &isin; nat"
  shows 
  "n &le; n #+ k"
  "n &sube; n #+ k"
  "n &sube; k #+ n"
proof -
  from A1 A2 have "n &le; n"  "0 &le; k"  "n &isin; nat"  "k &isin; nat"
    using nat_le_refl nat_0_le by auto
  then have "n #+ 0 &le; n #+ k" by (rule add_le_mono)
  with A1 show "n &le; n #+ k" using add_0_right by simp
  then show "n &sube; n #+ k" using le_imp_subset by simp
  then show "n &sube; k #+ n" using add_commute by simp
qed

text{*Result of adding an element of $k$ is smaller than of adding $k$. *}

lemma add_lt_mono: 
  assumes "k &isin; nat" and "j&isin;k"
  shows 
  "(n #+ j) &lt; (n #+ k)"
  "(n #+ j) &isin; (n #+ k)"
proof -
  from assms have "j &lt; k"  "k &isin; nat" using elem_nat_is_nat
    by blast
  then show "(n #+ j) &lt; (n #+ k)"   "(n #+ j) &isin; (n #+ k)"
    using add_lt_mono2 ltD by auto
qed

text{*A technical lemma about a decomposition of a sum of two natural
  numbers: if a number $i$ is from $m + n$ then it is either from $m$
  or can be written as a sum of $m$ and a number from $n$. 
  The proof by induction w.r.t. to $m$ seems to be a bit heavy-handed, but I could
  not figure out how to do this directly from results from standard Isabelle/ZF.*}

lemma nat_sum_decomp: assumes A1: "n &isin; nat"  and A2: "m &isin; nat"
  shows "&forall;i &isin; m #+ n. i &isin; m &or; (&exist;j &isin; n. i = m #+ j)" 
proof -
  note A1
  moreover from A2 have "&forall;i &isin; m #+ 0. i &isin; m &or; (&exist;j &isin; 0. i = m #+ j)"
    using add_0_right by simp
  moreover have "&forall;k&isin;nat.
    (&forall;i &isin; m #+ k. i &isin; m &or; (&exist;j &isin; k. i = m #+ j)) --&gt;
    (&forall;i &isin; m #+ succ(k). i &isin; m &or; (&exist;j &isin; succ(k). i = m #+ j))"
  proof -
    { fix k assume A3: "k &isin; nat"
      { assume A4: "&forall;i &isin; m #+ k. i &isin; m &or; (&exist;j &isin; k. i = m #+ j)"
          { fix i assume "i &isin;  m #+ succ(k)"
            then have "i &isin; m #+ k &or; i = m #+ k" using add_succ_right
              by auto
            moreover from A4 A3 have
              "i &isin; m #+ k --&gt; i &isin; m &or; (&exist;j &isin; succ(k). i = m #+ j)"
              by auto
            ultimately have "i &isin; m &or; (&exist;j &isin; succ(k). i = m #+ j)"
              by auto
          } then have "&forall;i &isin; m #+ succ(k). i &isin; m &or; (&exist;j &isin; succ(k). i = m #+ j)"
            by simp
      } then have "(&forall;i &isin; m #+ k. i &isin; m &or; (&exist;j &isin; k. i = m #+ j)) --&gt;
          (&forall;i &isin; m #+ succ(k). i &isin; m &or; (&exist;j &isin; succ(k). i = m #+ j))"
        by simp
    } then show ?thesis by simp
  qed
  ultimately show "&forall;i &isin; m #+ n. i &isin; m &or; (&exist;j &isin; n. i = m #+ j)"
    by (rule ind_on_nat)
qed

text{*A variant of induction useful for finite sequences.*}

lemma fin_nat_ind: assumes A1: "n &isin; nat" and A2: "k &isin; succ(n)"
  and A3: "P(0)" and A4: "&forall;j&isin;n. P(j)  --&gt; P(succ(j))"
  shows "P(k)"
proof -
  from A2 have "k &isin; n &or; k=n" by auto
  with A1 have "k &isin; nat" using elem_nat_is_nat by blast
  moreover from A3 have "0 &isin; succ(n) --&gt; P(0)" by simp
  moreover from A1 A4 have
    "&forall;k &isin; nat. (k &isin; succ(n) --&gt; P(k)) --&gt; (succ(k) &isin; succ(n) --&gt; P(succ(k)))"
    using nat_into_Ord Ord_succ_mem_iff by auto
  ultimately have "k &isin; succ(n) --&gt; P(k)"
    by (rule ind_on_nat)
  with A2 show "P(k)" by simp
qed

text{*Some properties of positive natural numbers.*}

lemma succ_plus: assumes "n &isin; nat"  "k &isin; nat"
  shows 
  "succ(n #+ j) &isin; nat" 
  "succ(n) #+ succ(j) = succ(succ(n #+ j))"
  using assms by auto

section{*Intervals*}

text{*In this section we consider intervals of natural numbers i.e. sets
  of the form $\{n+j : j \in 0..k-1\}$. *}

text{*The interval is determined
  by two parameters: starting point and length. Recall that in standard 
  Isabelle's @{text "Arith.thy"} the symbol @{text "#+"} is defined
  as the sum of natural numbers.*}

definition

  "NatInterval(n,k) &equiv; {n #+ j. j&isin;k}"

text{*Subtracting the beginning af the interval results in a number from
  the length of the interval.It may sound weird, but note that the length of
  such interval is a natural number, hence a set. *}

lemma inter_diff_in_len: 
  assumes A1: "k &isin; nat" and A2: "i &isin; NatInterval(n,k)"
  shows "i #- n &isin; k"
proof -
  from A2 obtain j where I: "i = n #+ j" and II: "j &isin; k"
    using NatInterval_def by auto
  from A1 II have "j &isin; nat" using elem_nat_is_nat by blast
  moreover from I have "i #- n = natify(j)" using diff_add_inverse
    by simp
  ultimately have "i #- n = j" by simp
  with II show ?thesis by simp
qed

text{*Intervals don't overlap with their starting point and 
  the union of an interval with its starting point is the sum of the starting
  point and the length of the interval.*}

lemma length_start_decomp: assumes  A1: "n &isin; nat"  "k &isin; nat"
  shows 
  "n &cap; NatInterval(n,k) = 0"
  "n &cup; NatInterval(n,k) = n #+ k"
proof -
  { fix i assume A2: "i &isin; n" and "i &isin; NatInterval(n,k)"
    then obtain j where I: "i = n #+ j" and II: "j &isin; k"
      using NatInterval_def by auto
    from A1 have "k &isin; nat" using elem_nat_is_nat by blast
    with II have "j &isin; nat" using elem_nat_is_nat by blast
    with A1 I have "n &le; i" using add_nat_le by simp
    moreover from A1 A2 have "i &lt; n" using elem_nat_is_nat by blast
    ultimately have False using le_imp_not_lt by simp
  } thus "n &cap; NatInterval(n,k) = 0" by auto
  from A1 have "n &sube; n #+ k" using add_nat_le by simp
  moreover
  { fix i assume "i &isin; NatInterval(n,k)"
    then obtain j where III: "i = n #+ j" and IV: "j &isin; k"
      using NatInterval_def by auto
    with A1 have "j &lt; k" using elem_nat_is_nat by blast
    with A1 III have "i &isin; n #+ k" using add_lt_mono2 ltD
      by simp }
  ultimately have "n &cup; NatInterval(n,k) &sube; n #+ k" by auto
  moreover from A1 have "n #+ k &sube; n &cup; NatInterval(n,k)" 
    using nat_sum_decomp NatInterval_def by auto
  ultimately show "n &cup; NatInterval(n,k) = n #+ k" by auto
qed

text{*Sme properties of three adjacent intervals.*}

lemma adjacent_intervals3: assumes "n &isin; nat"  "k &isin; nat"  "m &isin; nat"
  shows 
  "n #+ k #+ m = (n #+ k) &cup; NatInterval(n #+ k,m)"
  "n #+ k #+ m = n &cup; NatInterval(n,k #+  m)"
  "n #+ k #+ m = n &cup; NatInterval(n,k) &cup; NatInterval(n #+ k,m)"
  using assms add_assoc length_start_decomp by auto;

end
</pre>
</div>
<hr>
<div class="theorems">


<h2>Induction</h2>

<p><span class="command">theorem</span> <span class="name">ind_on_nat:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">P</span>(0); &forall;<span class="bound">k</span>&isin;<span class="const">nat</span>. <span class="var">P</span>(<span class="bound">k</span>) --&gt; <span class="var">P</span>(succ(<span class="bound">k</span>)) |] ==&gt; <span class="var">P</span>(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">Nat_ZF_1_L3:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">n</span> <span class="const">&ne;</span> 0 |] ==&gt; &exist;<span class="bound">k</span>&isin;<span class="const">nat</span>. <span class="var">n</span> = succ(<span class="bound">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">succ_explained:</span>
<pre>  <span class="term">succ(<span class="var">n</span>) = <span class="var">n</span> &cup; {<span class="var">n</span>}</span></pre></p>

<p><span class="command">lemma</span> <span class="name">empty_in_every_succ:</span>
<pre>  <span class="term"><span class="var">n</span> &isin; <span class="const">nat</span> ==&gt; 0 &isin; succ(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">succ_ineq:</span>
<pre>  <span class="term"><span class="var">n</span> &isin; <span class="const">nat</span> ==&gt; &forall;<span class="bound">i</span>&isin;<span class="var">n</span>. succ(<span class="bound">i</span>) &isin; succ(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">succ_subset:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &sube; <span class="var">n</span> |] ==&gt; succ(<span class="var">k</span>) &sube; succ(<span class="var">n</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">nat_incl_total:</span>
<pre>  <span class="term">[| <span class="var">i</span> &isin; <span class="const">nat</span>; <span class="var">j</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">i</span> &sube; <span class="var">j</span> &or; <span class="var">j</span> &sube; <span class="var">i</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">nat_union_succ:</span>
<pre>  <span class="term"><span class="const">nat</span> = (\&lt;Union&gt;<span class="bound">n</span>&isin;<span class="const">nat</span>. succ(<span class="bound">n</span>))</span></pre></p>

<p><span class="command">lemma</span> <span class="name">succnat_subset_nat:</span>
<pre>  <span class="term"><span class="var">n</span> &isin; <span class="const">nat</span> ==&gt; succ(<span class="var">n</span>) &sube; <span class="const">nat</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">elem_nat_is_nat(1):</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="var">n</span> |] ==&gt; <span class="var">k</span> <span class="const">&lt;</span> <span class="var">n</span></span></pre></p>


<p><span class="command">and</span> <span class="name">elem_nat_is_nat(2):</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="var">n</span> |] ==&gt; <span class="var">k</span> &isin; <span class="const">nat</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">add_nat_le:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> <span class="const">&le;</span> <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> &sube; <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> &sube; <span class="var">k</span> <span class="const">#+</span> <span class="var">n</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">add_lt_mono:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">j</span> &isin; <span class="var">k</span> |] ==&gt; <span class="var">n</span> <span class="const">#+</span> <span class="var">j</span> <span class="const">&lt;</span> <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span></span></pre>
<pre>  <span class="term">[| <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">j</span> &isin; <span class="var">k</span> |] ==&gt; <span class="var">n</span> <span class="const">#+</span> <span class="var">j</span> &isin; <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">nat_sum_decomp:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">m</span> &isin; <span class="const">nat</span> |] ==&gt; &forall;<span class="bound">i</span>&isin;<span class="var">m</span> <span class="const">#+</span> <span class="var">n</span>. <span class="bound">i</span> &isin; <span class="var">m</span> &or; (&exist;<span class="bound">j</span>&isin;<span class="var">n</span>. <span class="bound">i</span> = <span class="var">m</span> <span class="const">#+</span> <span class="bound">j</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">fin_nat_ind:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; succ(<span class="var">n</span>); <span class="var">P</span>(0); &forall;<span class="bound">j</span>&isin;<span class="var">n</span>. <span class="var">P</span>(<span class="bound">j</span>) --&gt; <span class="var">P</span>(succ(<span class="bound">j</span>)) |] ==&gt; <span class="var">P</span>(<span class="var">k</span>)</span></pre></p>

<p><span class="command">lemma</span> <span class="name">succ_plus:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; succ(<span class="var">n</span> <span class="const">#+</span> <span class="var">j</span>) &isin; <span class="const">nat</span></span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; succ(<span class="var">n</span>) <span class="const">#+</span> succ(<span class="var">j</span>) = succ(succ(<span class="var">n</span> <span class="const">#+</span> <span class="var">j</span>))</span></pre></p>


<h2>Intervals</h2>

<p><span class="command">lemma</span> <span class="name">inter_diff_in_len:</span>
<pre>  <span class="term">[| <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">i</span> &isin; <span class="const">NatInterval</span>(<span class="var">n</span>, <span class="var">k</span>) |] ==&gt; <span class="var">i</span> <span class="const">#-</span> <span class="var">n</span> &isin; <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">length_start_decomp:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> &cap; <span class="const">NatInterval</span>(<span class="var">n</span>, <span class="var">k</span>) = 0</span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> &cup; <span class="const">NatInterval</span>(<span class="var">n</span>, <span class="var">k</span>) = <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span></span></pre></p>

<p><span class="command">lemma</span> <span class="name">adjacent_intervals3:</span>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">m</span> &isin; <span class="const">nat</span> |]
  ==&gt; <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span> <span class="const">#+</span> <span class="var">m</span> = <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span> &cup; <span class="const">NatInterval</span>(<span class="var">n</span> <span class="const">#+</span> <span class="var">k</span>, <span class="var">m</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">m</span> &isin; <span class="const">nat</span> |] ==&gt; <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span> <span class="const">#+</span> <span class="var">m</span> = <span class="var">n</span> &cup; <span class="const">NatInterval</span>(<span class="var">n</span>, <span class="var">k</span> <span class="const">#+</span> <span class="var">m</span>)</span></pre>
<pre>  <span class="term">[| <span class="var">n</span> &isin; <span class="const">nat</span>; <span class="var">k</span> &isin; <span class="const">nat</span>; <span class="var">m</span> &isin; <span class="const">nat</span> |]
  ==&gt; <span class="var">n</span> <span class="const">#+</span> <span class="var">k</span> <span class="const">#+</span> <span class="var">m</span> = <span class="var">n</span> &cup; <span class="const">NatInterval</span>(<span class="var">n</span>, <span class="var">k</span>) &cup; <span class="const">NatInterval</span>(<span class="var">n</span> <span class="const">#+</span> <span class="var">k</span>, <span class="var">m</span>)</span></pre></p>

</div>
</body>
</html>
